<!DOCTYPE html>
<html>
<head>
    <title>Gravity Toy 3D</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script> <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            color: #ffffff;
            font-family: Courier New;
            font-size: 11px;
            background-color: black;
        }
        
        button {
            -webkit-border-radius: 0;
            -moz-border-radius: 0;
            border-radius: 0px;
            font-family: Courier New;
            color: #ffffff;
            font-size: 11px;
            background: #000000;
            padding: 5px 5px 5px 5px;
            border: solid #ffffff 1px;
            text-decoration: none;
            width: 176px; /* Doubled width from 88px */
            margin-top: 2px;
        }

        .txt {
            -webkit-border-radius: 0;
            -moz-border-radius: 0;
            border-radius: 0px;
            font-family: Courier New;
            color: #ffffff;
            font-size: 11px;
            background: #000000;
            padding: 5px 5px 5px 5px;
            border: solid #ffffff 1px;
            text-decoration: none;
            margin-left: 5px;
            width: 50px;
        }

        button:hover {
            background: #ffffff;
            color: #000000;
            text-decoration: none;
        }
        
        #controlbox {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
            border: solid #ffffff 1px;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
        }
        
        #homebox {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px;
            border: solid #ffffff 1px;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            font-size: 20px;
        }

        /* New: Status Bar Styling */
        #statusbar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            padding: 5px;
            border: solid #ffffff 1px;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        #statusbar div {
            margin: 0 10px;
        }
        #statusbar .txt {
            width: 60px; /* Adjust width for status bar inputs */
            text-align: center;
        }
        
        a:link {
            color: #0080FF;
            text-decoration: none;
        }
        
        a:visited {
            color: #0000FF;
            text-decoration: none;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="controlbox">
        <div>Gravity</div><br>
        
        <button onclick="toggleMatterType()">Toggle Matter (U)</button><br>
        
        <div id="particleCount">Particles: 0</div><br> <table>
            <tr>Mass:<input type="text" value="1.0e3" class="txt" id="mass"></tr><br>
            <tr><button onclick="setSize(100)">Tiny (1)</button></tr><br>
            <tr><button onclick="setSize(1000)">Small (2)</button></tr><br>
            <tr><button onclick="setSize(10000)">Medium (3)</button></tr><br>
            <tr><button onclick="setSize(100000)">Huge (4)</button></tr><br>
            <tr><button onclick="setSize(1000000)">Enormous (5)</button></tr><br>
            <tr><button onclick="currentParticleType = 'supernova'; setSize(300000000 * ( 1 + (Math.random())) , 'Supernova', 0.5, [253, 238, 150])">Supernova</button></tr><br>
            <tr><button onclick="currentParticleType = 'neutron'; setSize(300000000 * ( 1 + (Math.random())) , 'Neutron Star', 9, 'neutron');">Neutron Star</button></tr><br>
            <tr><button onclick="currentParticleType = 'blackhole'; setSize(1000000000 * ( 1 + (Math.random())) , 'Black Hole', 10, 'blackhole');">Black Hole</button></tr><br>
        </table>
        
        <button onclick="startSimulation()">Start (S)</button><br>
        <button onclick="stopSimulation()">Stop (s)</button><br>
        <button onclick="generateProto()">Protodisk (D)</button><br>
        <button onclick="generateRandomSystem()">Random System (R)</button><br>
        <button onclick="generateAsteroidBelt()">Asteroid Belt (K)</button><br>
        <button onclick="generateSolarSystem()">Solar System (Y)</button><br> <button onclick="clearParticles()">Clear (C)</button><br>
        <button onclick="toggleOrbits()">Toggle Orbits (O)</button><br>
        <button onclick="addMoon()">Add Moon (A)</button><br>
        <button onclick="toggleNames()">Toggle Name (N)</button><br>
        <button onclick="toggleMasses()">Toggle Mass (M)</button><br>
        <table>
            <tr><button onclick="setSize(100000000 , 'Sun')">Sun</button></tr> <br>
            <tr><button onclick="setSize(16.6 , 'Mercury')">Mercury</button></tr><br>
            <tr><button onclick="setSize(245 , 'Venus')">Venus</button></tr><br>
            <tr><button onclick="setSize(300 , 'Earth')">Earth</button></tr><br>
            <tr><button onclick="setSize(32.3 , 'Mars')">Mars</button></tr><br>
            <tr><button onclick="setSize(95400 , 'Jupiter')">Jupiter</button></tr><br>
            <tr><button onclick="setSize(28570 , 'Saturn')">Saturn</button></tr><br>
            <tr><button onclick="setSize(4360 , 'Uranus')">Uranus</button></tr><br>
            <tr><button onclick="setSize(5150 , 'Neptune')">Neptune</button></tr><br>
        </table>
    </div>
    
    <div id="homebox">Gravity Toy 3D</div>
    
    <canvas id="renderCanvas"></canvas>

    <div id="statusbar">
        <div>
            Speed: <input type="text" id="simulationSpeedInput" class="txt" value="1.0" onchange="setSimulationSpeed(parseFloat(this.value))">
        </div>
        <div>
            Zoom: <input type="text" id="cameraZoomInput" class="txt" value="200" onchange="setCameraZoom(parseFloat(this.value))">
        </div>
    </div>
    
    <script>
        // Variables globales
        let canvas, engine, scene, camera;
        let particles = [];
        let newParticleMass = 1000;
        let currentParticleDisplayName = 'ClickParticle'; // New: Stores the base name for new particles
        let isSimulationRunning = true;
        let isDragging = false;
        let startX, startY;
        let showOrbits = false; // To control orbit visibility
        let showNames = false; // New: To control name label visibility
        let showMasses = false; // New: To control mass label visibility
        const ORBIT_POINTS_LIMIT = 500; // Limit for orbit points
        const ORBIT_DRAW_INTERVAL = 5; // Draw orbit point every X frames
        const G_EFFECTIVE = 0.0001; // Gravitational constant adjusted for simulation scale
        let currentParticleType = 'matter'; // Default to matter
        let particleIdCounter = 0; // New: Counter for unique particle IDs
        let advancedTexture; // New: For GUI

        // New globals for particle properties
        let newParticleDiameter = 1; // Default diameter
        let newParticleColorOverride = null; // Can be an RGB array or a string like 'neutron', 'blackhole'

        // New: Time and Zoom controls
        let simulationSpeedMultiplier = 1.0; // Default simulation speed
        let currentCameraZoom = 200; // Default camera zoom

        // New function to get a random color
        function getRandomColor() {
            const colors = [
                new BABYLON.Color3(0, 0, 1),      // Blue
                new BABYLON.Color3(0.5, 0, 1),    // Violet
                new BABYLON.Color3(0, 1, 0),      // Green
                new BABYLON.Color3(0.6, 0.4, 0.2),// Brown
                new BABYLON.Color3(0.7, 0.7, 0.7),// Gray
                new BABYLON.Color3(1, 0.7, 0.8),  // Pink
                new BABYLON.Color3(1, 1, 0),      // Yellow
                new BABYLON.Color3(1, 0.5, 0)     // Orange
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // New helper function for special particle colors (Neutron Star, Black Hole)
        function getSpecialColorForType(typeString) {
            switch (typeString) {
                case 'neutron': return new BABYLON.Color3(0.7, 0.7, 1); // Bluish-white for neutron star
                case 'blackhole': return new BABYLON.Color3(0.05, 0.05, 0.05); // Very dark gray for black hole
                case 'supernova': return new BABYLON.Color3(253 / 255, 238 / 255, 150 / 255); // Pale yellow from user input
                default: return new BABYLON.Color3(1, 1, 1); // Default white if unknown
            }
        }


        // Inicialización de Babylon.js
        window.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 0, 0); // Set background color to black
            
            // New: Initialize GUI for text labels
            advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            // Configurar cámara
            camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 2, 200, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 2000;
            camera.wheelPrecision = 50;
            currentCameraZoom = camera.radius; // Initialize with camera's actual radius
            document.getElementById("cameraZoomInput").value = currentCameraZoom.toFixed(0);

            // Configurar luz
            let light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;
            
            // Eventos del ratón
            canvas.addEventListener("pointerdown", function(evt) {
                if (evt.button === 0) { // Click izquierdo
                    if (!isDragging) {
                        addParticle(evt.clientX, evt.clientY);
                    }
                }
                isDragging = false;
                startX = evt.clientX;
                startY = evt.clientY;
            });
            
            canvas.addEventListener("pointermove", function(evt) {
                if (Math.abs(evt.clientX - startX) > 5 || Math.abs(evt.clientY - startY) > 5) {
                    isDragging = true;
                }
            });

            // Keyboard event for toggling orbits
            window.addEventListener("keydown", function(evt) {
                if (evt.key === "o" || evt.key === "O") { // Changed back to 'o' for Toggle Orbits
                    toggleOrbits();
                }
                else if (evt.key === "n" || evt.key === "N") { // Toggle Name with 'N'
                    toggleNames();
                }
                else if (evt.key === "m" || evt.key === "M") { // Toggle Mass with 'M'
                    toggleMasses();
                }
                else if (evt.key === "a" || evt.key === "A") { // Add Moon with 'A'
                    addMoon();
                }
                else if (evt.key === "u" || evt.key === "U") { // Toggle Matter Type with 'U'
                    toggleMatterType();
                }
                else if (evt.key === "y" || evt.key === "Y") { // Solar System with 'Y'
                    generateSolarSystem();
                }
                else if (evt.key === "1") { // Tiny (1)
                    setSize(100);
                }
                else if (evt.key === "2") { // Small (2)
                    setSize(1000);
                }
                else if (evt.key === "3") { // Medium (3)
                    setSize(10000);
                }
                else if (evt.key === "4") { // Huge (4)
                    setSize(100000);
                }
                else if (evt.key === "5") { // Enormous (5)
                    setSize(1000000);
                }
                else if (evt.key === "d" || evt.key === "D") { // Protodisk (D)
                    generateProto();
                }
                else if (evt.key === "k" || evt.key === "K") { // Asteroid Belt (K)
                    generateAsteroidBelt();
                }
                else if (evt.key === "S") { // Start (S) - Capital S for Start
                    startSimulation();
                }
                else if (evt.key === "s") { // Stop (s) - Lowercase s for Stop
                    stopSimulation();
                }
                else if (evt.key === "c" || evt.key === "C") { // Clear (C)
                    clearParticles();
                }
                else if (evt.key === "r" || evt.key === "R") { // Random System (R)
                    generateRandomSystem();
                }
            });
            
            // Iniciar simulación
            let frameCount = 0; // Frame counter for orbit drawing
            engine.runRenderLoop(function() {
                if (isSimulationRunning) {
                    updateParticles();
                    frameCount++; // Increment frame counter
                    if (showOrbits && frameCount % ORBIT_DRAW_INTERVAL === 0) {
                        updateOrbitMeshes(); // Update orbits less frequently
                    }
                    // New: Update labels every frame
                    updateParticleLabels();
                }
                // New: Update zoom display if camera radius changes due to user interaction
                if (camera.radius !== currentCameraZoom) {
                    currentCameraZoom = camera.radius;
                    document.getElementById("cameraZoomInput").value = currentCameraZoom.toFixed(0);
                }
                scene.render();
            });
            
            // Manejar redimensionamiento de ventana
            window.addEventListener("resize", function() {
                engine.resize();
            });

            updateParticleCountDisplay(); // Initialize display on load
        });
        
        // New: Set simulation speed
        function setSimulationSpeed(speed) {
            if (speed > 0 && speed <= 100) { // Limit speed to a reasonable range
                simulationSpeedMultiplier = speed;
                document.getElementById("simulationSpeedInput").value = simulationSpeedMultiplier.toFixed(1);
                console.log(`Simulation speed set to: ${simulationSpeedMultiplier}x`);
            } else {
                alert("Please enter a speed between 0.1 and 100.");
                document.getElementById("simulationSpeedInput").value = simulationSpeedMultiplier.toFixed(1); // Revert to current value
            }
        }

        // New: Set camera zoom
        function setCameraZoom(zoom) {
            if (zoom >= camera.lowerRadiusLimit && zoom <= camera.upperRadiusLimit) {
                camera.radius = zoom;
                currentCameraZoom = zoom;
                document.getElementById("cameraZoomInput").value = currentCameraZoom.toFixed(0);
                console.log(`Camera zoom set to: ${currentCameraZoom}`);
            } else {
                alert(`Please enter a zoom value between ${camera.lowerRadiusLimit} and ${camera.upperRadiusLimit}.`);
                document.getElementById("cameraZoomInput").value = currentCameraZoom.toFixed(0); // Revert to current value
            }
        }

        // New: Toggle particle type between matter and antimatter
        function toggleMatterType() {
            currentParticleType = (currentParticleType === 'matter') ? 'antimatter' : 'matter';
            console.log(`Particle type toggled to: ${currentParticleType}`);
        }

        // Function to get color based on mass and type (still used for non-random system particles)
        function getColorByMass(mass, type) {
            let color;
            if (type === 'antimatter') {
                if (mass < 500) color = new BABYLON.Color3(0.5, 0.5, 1);    // Light Blue
                else if (mass < 5000) color = new BABYLON.Color3(0.3, 0.3, 1); // Medium Blue
                else if (mass < 50000) color = new BABYLON.Color3(0.1, 0.1, 1); // Dark Blue
                else color = new BABYLON.Color3(0, 0, 0.8);                  // Very Dark Blue
            } else { // Matter
                if (mass < 500) color = new BABYLON.Color3(1, 1, 1);     // White
                else if (mass < 5000) color = new BABYLON.Color3(1, 1, 0);    // Yellow
                else if (mass < 50000) color = new BABYLON.Color3(1, 0.5, 0); // Orange
                else color = new BABYLON.Color3(1, 0, 0);                    // Red
            }
            return color;
        }

        // Functions de simulación
        function updateParticles() {
            let particlesToRemove = new Set();
            
            // Apply gravity between all particles
            for (let i = 0; i < particles.length; i++) {
                if (particlesToRemove.has(i)) continue; // Skip if already marked for removal

                let p1 = particles[i];
                let totalForce = new BABYLON.Vector3(0, 0, 0);
                
                for (let j = 0; j < particles.length; j++) {
                    if (i === j || particlesToRemove.has(j)) continue; // Skip self or already marked for removal

                    let p2 = particles[j];

                    let direction = p2.position.subtract(p1.position);
                    let distanceSquared = direction.lengthSquared();
                    let distance = Math.sqrt(distanceSquared);
                    
                    // Collision detection based on current mesh scaling (radius = diameter / 2)
                    let radius1 = p1.mesh.scaling.x / 2;
                    let radius2 = p2.mesh.scaling.x / 2;
                    let collisionThreshold = radius1 + radius2;

                    if (distance < collisionThreshold && distance > 0.01) { // Collision detected
                        console.log(`Collision detected between ${p1.name} (${p1.type}, ${p1.mass.toFixed(0)}) and ${p2.name} (${p2.type}, ${p2.mass.toFixed(0)})`);
                        
                        // Handle specific types (Supernova, Neutron Star, Black Hole) first
                        if (p1.type === 'supernova' || p2.type === 'supernova') {
                            // Supernovas could explode, scattering particles, or simply merge.
                            // For simplicity, let's have them merge and create a powerful burst effect
                            // (represented by increased size and a short duration intense light, then collapse)
                            // This would be complex to fully simulate. For now, they'll act as regular matter.
                             console.log("Supernova collision - currently acts as regular matter merge.");
                        } else if (p1.type === 'neutron' || p2.type === 'neutron') {
                            // Neutron stars could merge into a larger neutron star or a black hole.
                             console.log("Neutron Star collision - currently acts as regular matter merge.");
                        } else if (p1.type === 'blackhole' || p2.type === 'blackhole') {
                            // Black holes merge into a larger black hole.
                             console.log("Black Hole collision - they will merge.");
                            let mergedMass = p1.mass + p2.mass;
                            let mergedVelocity = p1.velocity.scale(p1.mass).add(p2.velocity.scale(p2.mass)).scale(1 / mergedMass);

                            p1.mass = mergedMass;
                            p1.velocity = mergedVelocity;
                            // Black holes are always black, no color change based on mass
                            particlesToRemove.add(j);
                            console.log(`Black Hole: ${p1.name} merged with ${p2.name}. New mass: ${p1.mass.toFixed(0)}`);
                        } else if (p1.type !== p2.type) { // Matter-Antimatter collision
                            let remainingMass = Math.abs(p1.mass - p2.mass);
                            
                            if (remainingMass > 0) {
                                // The more massive particle survives with reduced mass
                                let survivor = p1.mass > p2.mass ? p1 : p2;
                                let absorbed = p1.mass > p2.mass ? p2 : p1;

                                // Update survivor's properties
                                survivor.mass = remainingMass;
                                survivor.mesh.material.emissiveColor = getColorByMass(survivor.mass, survivor.type); // Re-color based on new mass
                                particlesToRemove.add(particles.indexOf(absorbed));
                                console.log(`Matter-Antimatter: ${absorbed.name} annihilated. ${survivor.name} (${survivor.type}) with ${survivor.mass.toFixed(0)} remains.`);

                            } else { // Masses are equal, both annihilated
                                particlesToRemove.add(i);
                                particlesToRemove.add(j);
                                console.log(`Matter-Antimatter: Both ${p1.name} and ${p2.name} of mass ${p1.mass.toFixed(0)} annihilated.`);
                            }
                        } else { // Matter-Matter or Antimatter-Antimatter collision (merge)
                            let mergedMass = p1.mass + p2.mass;
                            
                            // Conserve momentum (simplified: assume p1 absorbs p2)
                            let mergedVelocity = p1.velocity.scale(p1.mass).add(p2.velocity.scale(p2.mass)).scale(1 / mergedMass);

                            p1.mass = mergedMass;
                            p1.velocity = mergedVelocity;
                            p1.mesh.material.emissiveColor = getColorByMass(p1.mass, p1.type); // Re-color based on new mass
                            particlesToRemove.add(j); // Mark the second particle for removal
                            console.log(`${p1.type}-${p1.type}: ${p1.name} merged with ${p2.name}. New mass: ${p1.mass.toFixed(0)}`);
                        }
                    }
                    
                    // Apply gravitational force
                    if (distanceSquared > 0.1) { // Avoid division by zero for gravity calculation
                        let forceMagnitude = (p1.mass * p2.mass) / distanceSquared;
                        direction.normalize();
                        totalForce.addInPlace(direction.scale(forceMagnitude * G_EFFECTIVE));
                    }
                }
                
                // Update velocity (F = ma => a = F/m)
                if (p1.mass > 0) { // Only update if particle still has mass
                    p1.velocity.addInPlace(totalForce.scale(1 / p1.mass));
                }
            }

            // Remove particles marked for removal
            let finalParticles = [];
            for (let i = 0; i < particles.length; i++) {
                if (!particlesToRemove.has(i)) {
                    finalParticles.push(particles[i]);
                } else {
                    console.log(`Disposing of particle: ${particles[i].name}`);
                    particles[i].mesh.dispose();
                    if (particles[i].orbitMesh) {
                        particles[i].orbitMesh.dispose();
                    }
                    // New: Dispose of text labels
                    if (particles[i].nameText) {
                        particles[i].nameText.dispose();
                    }
                    if (particles[i].massText) {
                        particles[i].massText.dispose();
                    }
                }
            }
            particles = finalParticles; // Replace with updated list

            // Update positions of remaining particles
            for (let particle of particles) {
                if (particle.mass <= 0) { // Ensure no zero or negative mass particles remain
                    particlesToRemove.add(particles.indexOf(particle)); // Mark for removal if somehow mass became zero
                    continue; 
                }
                particle.position.addInPlace(particle.velocity.scale(simulationSpeedMultiplier)); // Apply speed multiplier
                particle.mesh.position.copyFrom(particle.position);
                
                // Update size based on the mass (logarithmic for better visualization)
                let scale = Math.log10(particle.mass + 1) / 2; // Increased scale factor (was /4)
                if (scale < 0.2) scale = 0.2; // Increased minimum size (was 0.1)
                
                // For Black Holes, keep diameter fixed as per button spec, scale mesh by that
                if (particle.type === 'blackhole') {
                    particle.mesh.scaling.set(particle.initialDiameter || 10, particle.initialDiameter || 10, particle.initialDiameter || 10);
                } else {
                    particle.mesh.scaling.set(scale, scale, scale);
                }
                

                // Add current position to orbit points
                particle.orbitPoints.push(particle.position.clone());
                if (particle.orbitPoints.length > ORBIT_POINTS_LIMIT) {
                    particle.orbitPoints.shift(); // Remove the oldest point
                }
            }
            updateParticleCountDisplay(); // Update counter after any changes
        }

        // Function to update orbit meshes
        function updateOrbitMeshes() {
            for (let particle of particles) {
                if (showOrbits) {
                    if (particle.orbitMesh) {
                        // Update existing line mesh if it has enough points
                        if (particle.orbitPoints.length > 1) {
                            BABYLON.MeshBuilder.CreateLines("orbitLines", {points: particle.orbitPoints, instance: particle.orbitMesh}, scene);
                        }
                    } else {
                        // Create new line mesh if it doesn't exist and has enough points
                        if (particle.orbitPoints.length > 1) {
                            particle.orbitMesh = BABYLON.MeshBuilder.CreateLines("orbitLines", {points: particle.orbitPoints, updatable: true}, scene);
                            particle.orbitMesh.color = particle.mesh.material.emissiveColor; // Match orbit color to particle color
                        }
                    }
                } else {
                    // If orbits are not shown, dispose of the mesh
                    if (particle.orbitMesh) {
                        particle.orbitMesh.dispose();
                        particle.orbitMesh = null;
                    }
                }
            }
        }

        // New: Function to update particle labels (name and mass)
        function updateParticleLabels() {
            for (let particle of particles) {
                if (!particle.nameText) {
                    // Create name text block if it doesn't exist
                    particle.nameText = new BABYLON.GUI.TextBlock();
                    particle.nameText.color = "white";
                    particle.nameText.fontSize = 10;
                    advancedTexture.addControl(particle.nameText);
                    particle.nameText.linkWithMesh(particle.mesh);
                    particle.nameText.linkOffsetY = -30; // Offset above the particle
                }

                if (!particle.massText) {
                    // Create mass text block if it doesn't exist
                    particle.massText = new BABYLON.GUI.TextBlock();
                    particle.massText.color = "lightgray";
                    particle.massText.fontSize = 9;
                    advancedTexture.addControl(particle.massText);
                    particle.massText.linkWithMesh(particle.mesh);
                    particle.massText.linkOffsetY = -15; // Offset above the particle, below name
                }

                // Update visibility based on global flags
                particle.nameText.isVisible = showNames;
                particle.massText.isVisible = showMasses;

                // Update text content
                if (showNames) {
                    particle.nameText.text = particle.name;
                }
                if (showMasses) {
                    particle.massText.text = `Mass: ${particle.mass.toExponential(1).replace("+", "")}`;
                }
            }
        }
        
        function addParticle(screenX, screenY) {
            // Convertir coordenadas de pantalla a posición 3D
            let pickInfo = scene.pick(screenX, screenY);
            let position;
            
            if (pickInfo.hit) {
                position = pickInfo.pickedPoint;
            } else {
                // Si no se hizo click en un objeto, crear en un plano imaginario
                let ray = scene.createPickingRay(screenX, screenY, BABYLON.Matrix.Identity(), camera);
                // Calcular posición a una distancia fija
                position = ray.origin.add(ray.direction.scale(10));
            }
            
            // Use currentParticleDisplayName as base name
            let particleName = `${currentParticleDisplayName || 'ClickParticle'}-${particleIdCounter++}`; 
            // Use newParticleDiameter for sphere creation
            let sphere = BABYLON.MeshBuilder.CreateSphere(particleName, {diameter: newParticleDiameter}, scene);
            sphere.position = position;
            
            // Create a new material for each particle to set individual colors
            let particleMaterial = new BABYLON.StandardMaterial("particleMat" + particles.length, scene);
            
            // Determine color based on newParticleColorOverride first
            if (typeof newParticleColorOverride === 'string') { // For 'neutron' or 'blackhole' or 'supernova'
                particleMaterial.emissiveColor = getSpecialColorForType(newParticleColorOverride);
            } else if (Array.isArray(newParticleColorOverride)) { // For RGB array
                particleMaterial.emissiveColor = new BABYLON.Color3(
                    newParticleColorOverride[0] / 255,
                    newParticleColorOverride[1] / 255,
                    newParticleColorOverride[2] / 255
                );
            } else { // Fallback to existing logic based on mass and currentParticleType
                particleMaterial.emissiveColor = getColorByMass(newParticleMass, currentParticleType); 
            }
            sphere.material = particleMaterial;
            
            let particle = {
                name: particleName, // Add name property
                mesh: sphere,
                position: position.clone(),
                velocity: new BABYLON.Vector3(0, 0, 0),
                mass: newParticleMass,
                initialDiameter: newParticleDiameter, // Store initial diameter for types like Black Holes
                orbitPoints: [position.clone()], // Start with initial position
                orbitMesh: null,  // Mesh for the orbit line
                type: currentParticleType, // New: particle type
                nameText: null, // New: TextBlock for name
                massText: null
            };
            
            particles.push(particle);
            console.log(`Added particle ${particle.name} (${particle.type}) with mass ${newParticleMass.toFixed(0)}`);
            updateParticleCountDisplay(); // Update counter
        }
        
        function generateProto() {
            clearParticles();
            
            // Añadir una partícula central masiva (always matter)
            let centralMass = 100000;
            let centralParticleName = `CentralStar-${particleIdCounter++}`;
            let centralSphere = BABYLON.MeshBuilder.CreateSphere(centralParticleName, {diameter: 1}, scene);
            centralSphere.position = BABYLON.Vector3.Zero();
            
            let centralMaterial = new BABYLON.StandardMaterial("centralMat", scene);
            centralMaterial.emissiveColor = getColorByMass(centralMass, 'matter'); // Central body is always matter
            centralSphere.material = centralMaterial;
            
            let centralParticle = {
                name: centralParticleName, // Add name property
                mesh: centralSphere,
                position: BABYLON.Vector3.Zero(),
                velocity: new BABYLON.Vector3(0, 0, 0),
                mass: centralMass,
                initialDiameter: 1, // Default diameter
                orbitPoints: [BABYLON.Vector3.Zero()],
                orbitMesh: null,
                type: 'matter', // Central body is always matter
                nameText: null, // New: TextBlock for name
                massText: null
            };
            particles.push(centralParticle);
            console.log(`Generated central particle ${centralParticle.name}.`);

            // Crear un disco protoplanetario de partículas
            const numProtoParticles = 350; 
            for (let i = 0; i < numProtoParticles; i++) {
                let randRadius = 30 + (Math.random() * 40); // Increased radius between 30 and 70
                let randAngle = Math.random() * 2 * Math.PI;
                let x = randRadius * Math.cos(randAngle);
                let y = randRadius * Math.sin(randAngle);
                let z = (Math.random() - 0.5) * 1; // Slight vertical spread

                let initialPosition = new BABYLON.Vector3(x, z, y);
                
                let mass = 1000; // Default mass for protoplanet particles
                
                // Calculate tangential velocity for orbit around the central particle
                let distance = initialPosition.subtract(centralParticle.position).length();
                let orbitalSpeed = Math.sqrt(G_EFFECTIVE * centralParticle.mass / distance);
                
                let directionFromCenter = initialPosition.subtract(centralParticle.position).normalize();
                
                // Define a general normal for the disk plane (mostly Y, with slight randomness)
                let orbitNormal = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 0.1, // Small random variation for X
                    1,                           // Predominantly Y-axis
                    (Math.random() - 0.5) * 0.1  // Small random variation for Z
                ).normalize();

                // Calculate tangential direction using cross product (perpendicular to radius and orbit normal)
                let tangentialDirection = BABYLON.Vector3.Cross(directionFromCenter, orbitNormal).normalize();

                // Randomly choose clockwise or counter-clockwise
                let orbitalDirectionMultiplier = Math.random() < 0.5 ? 1 : -1;
                tangentialDirection.scaleInPlace(orbitalDirectionMultiplier);

                let velocity = centralParticle.velocity.add(tangentialDirection.scale(orbitalSpeed));

                let protoParticleName = `ProtoParticle-${particleIdCounter++}`;
                let sphere = BABYLON.MeshBuilder.CreateSphere(protoParticleName, {diameter: 1}, scene);
                sphere.position = initialPosition;
                
                let particleMaterial = new BABYLON.StandardMaterial("protoParticleMat" + i, scene);
                particleMaterial.emissiveColor = getColorByMass(mass, currentParticleType); // Use current type for planets
                sphere.material = particleMaterial;

                particles.push({
                    name: protoParticleName, // Add name property
                    mesh: sphere,
                    position: initialPosition.clone(),
                    velocity: velocity,
                    mass: mass,
                    initialDiameter: 1, // Default diameter
                    orbitPoints: [initialPosition.clone()],
                    orbitMesh: null,
                    type: currentParticleType, // Assign current type
                    nameText: null, // New: TextBlock for name
                    massText: null
                });
            }
            console.log(`Generated Protodisk with ${particles.length} particles. Matter Type: ${currentParticleType}`);
            updateParticleCountDisplay(); // Update counter
        }

        // Function to generate a more stable random system with colored particles
        function generateRandomSystem() {
            clearParticles();

            // 1. Create a very massive central body (always matter)
            const centralMass = 5.0e7; // Extremely massive to dominate gravity
            let centralSystemBodyName = `SystemCenter-${particleIdCounter++}`;
            let centralSphere = BABYLON.MeshBuilder.CreateSphere(centralSystemBodyName, {diameter: 1}, scene);
            centralSphere.position = BABYLON.Vector3.Zero();
            let centralMaterial = new BABYLON.StandardMaterial("centralSystemMat", scene);
            centralMaterial.emissiveColor = new BABYLON.Color3(1, 0.8, 0); // Sun-like color for central body
            centralSphere.material = centralMaterial;
            let centralParticle = {
                name: centralSystemBodyName,
                mesh: centralSphere,
                position: BABYLON.Vector3.Zero(),
                velocity: new BABYLON.Vector3(0, 0, 0),
                mass: centralMass,
                initialDiameter: 1, // Default diameter
                orbitPoints: [BABYLON.Vector3.Zero()],
                orbitMesh: null,
                type: 'matter',
                nameText: null,
                massText: null
            };
            particles.push(centralParticle);
            console.log(`Generated central system body ${centralParticle.name}.`);

            // 2. Generate orbiting "planets" or "moons"
            const numPlanets = 10 + Math.floor(Math.random() * 20); // Between 10 and 29 planets
            const innerOrbitRadius = 30;
            const outerOrbitRadius = 150;
            const orbitalPlaneSpread = 5; // How much deviation from the main orbital plane

            for (let i = 0; i < numPlanets; i++) {
                let randomRadius = innerOrbitRadius + (Math.random() * (outerOrbitRadius - innerOrbitRadius));
                let randomAngle = Math.random() * 2 * Math.PI;
                let randomHeight = (Math.random() - 0.5) * orbitalPlaneSpread;

                let position = new BABYLON.Vector3(
                    randomRadius * Math.cos(randomAngle),
                    randomHeight,
                    randomRadius * Math.sin(randomAngle)
                );

                let mass = 1000 + Math.random() * 99000; // Random mass for planets/moons

                // Calculate tangential velocity for a stable orbit around the central body
                let distance = position.subtract(centralParticle.position).length();
                let orbitalSpeed = Math.sqrt(G_EFFECTIVE * centralParticle.mass / distance);

                let directionFromCenter = position.subtract(centralParticle.position).normalize();
                
                // Use a consistent normal for the main plane (Y-axis), but allow for slight inclination
                let orbitNormal = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    1,
                    (Math.random() - 0.5) * 0.1
                ).normalize();

                let tangentialDirection = BABYLON.Vector3.Cross(directionFromCenter, orbitNormal).normalize();

                // Randomly choose clockwise or counter-clockwise
                let orbitalDirectionMultiplier = Math.random() < 0.5 ? 1 : -1;
                tangentialDirection.scaleInPlace(orbitalDirectionMultiplier);

                let velocity = centralParticle.velocity.add(tangentialDirection.scale(orbitalSpeed));

                let planetName = `Planet-${particleIdCounter++}`;
                let sphere = BABYLON.MeshBuilder.CreateSphere(planetName, {diameter: 1}, scene);
                sphere.position = position;
                
                let particleMaterial = new BABYLON.StandardMaterial("planetMat" + i, scene);
                particleMaterial.emissiveColor = getRandomColor(); // Use random color for planets
                sphere.material = particleMaterial;

                particles.push({
                    name: planetName,
                    mesh: sphere,
                    position: position.clone(),
                    velocity: velocity,
                    mass: mass,
                    initialDiameter: 1, // Default diameter
                    orbitPoints: [position.clone()],
                    orbitMesh: null,
                    type: currentParticleType, // Assign current type for planets
                    nameText: null,
                    massText: null
                });
            }
            console.log(`Generated Random System with ${particles.length} particles. Matter Type: ${currentParticleType}`);
            updateParticleCountDisplay();
        }
        
        // Function to generate an asteroid belt
        function generateAsteroidBelt() {
            clearParticles();

            // Create a central, massive body (always matter for belt)
            let centralMass = 150000;
            let centralAsteroidBodyName = `CentralMass-${particleIdCounter++}`;
            let centralSphere = BABYLON.MeshBuilder.CreateSphere(centralAsteroidBodyName, {diameter: 1}, scene);
            centralSphere.position = BABYLON.Vector3.Zero();
            let centralMaterial = new BABYLON.StandardMaterial("centralAsteroidMat", scene);
            centralMaterial.emissiveColor = getColorByMass(centralMass, 'matter'); // Central body is always matter
            centralSphere.material = centralMaterial;
            let centralParticle = {
                name: centralAsteroidBodyName, // Add name property
                mesh: centralSphere,
                position: BABYLON.Vector3.Zero(),
                velocity: new BABYLON.Vector3(0, 0, 0),
                mass: centralMass,
                initialDiameter: 1, // Default diameter
                orbitPoints: [BABYLON.Vector3.Zero()],
                orbitMesh: null,
                type: 'matter', // Central body is always matter
                nameText: null,
                massText: null
            };
            particles.push(centralParticle);
            console.log(`Generated central asteroid body ${centralParticle.name}.`);

            const numAsteroids = 500; 
            const innerRadius = 50; // Increased inner radius significantly
            const outerRadius = 90; // Increased outer radius significantly
            const beltThickness = 5; // Vertical thickness of the belt

            for (let i = 0; i < numAsteroids; i++) {
                let randomRadius = innerRadius + (Math.random() * (outerRadius - innerRadius));
                let randomAngle = Math.random() * 2 * Math.PI;
                let randomHeight = (Math.random() - 0.5) * beltThickness; // Spread vertically

                let position = new BABYLON.Vector3(
                    randomRadius * Math.cos(randomAngle),
                    randomHeight,
                    randomRadius * Math.sin(randomAngle)
                );

                let mass = 50 + Math.random() * 950; // Different masses for asteroids (50 to 1000)

                // Calculate tangential velocity for a stable orbit around the central body
                let distance = position.subtract(centralParticle.position).length();
                let orbitalSpeed = Math.sqrt(G_EFFECTIVE * centralParticle.mass / distance);

                // Direction vector from center to asteroid
                let directionFromCenter = position.subtract(centralParticle.position).normalize();
                
                // Introduce randomness for orbital plane/axis (similar to addMoon)
                let orbitNormal = new BABYLON.Vector3(
                    Math.random() * 0.5 - 0.25, // Small random variation for X
                    1 + (Math.random() * 0.5 - 0.25), // Predominantly Y, with small random variation
                    Math.random() * 0.5 - 0.25  // Small random variation for Z
                ).normalize();
                // Ensure orbitNormal is not too close to directionFromCenter for cross product stability
                if (BABYLON.Vector3.Dot(directionFromCenter, orbitNormal) > 0.95) { // If nearly parallel
                    orbitNormal = new BABYLON.Vector3(1, 0, 0).normalize(); // Default to X axis for a different cross product
                }

                let tangentialDirection = BABYLON.Vector3.Cross(directionFromCenter, orbitNormal).normalize();

                // Randomly choose clockwise or counter-clockwise
                let orbitalDirectionMultiplier = Math.random() < 0.5 ? 1 : -1;
                tangentialDirection.scaleInPlace(orbitalDirectionMultiplier);

                let velocity = centralParticle.velocity.add(tangentialDirection.scale(orbitalSpeed));

                let asteroidName = `Asteroid-${particleIdCounter++}`;
                let sphere = BABYLON.MeshBuilder.CreateSphere(asteroidName, {diameter: 1}, scene);
                sphere.position = position;
                
                let particleMaterial = new BABYLON.StandardMaterial("asteroidMat" + i, scene);
                particleMaterial.emissiveColor = getColorByMass(mass, currentParticleType); // Use current type
                sphere.material = particleMaterial;

                particles.push({
                    name: asteroidName, // Add name property
                    mesh: sphere,
                    position: position.clone(),
                    velocity: velocity,
                    mass: mass,
                    initialDiameter: 1, // Default diameter
                    orbitPoints: [position.clone()],
                    orbitMesh: null,
                    type: currentParticleType, // Assign current type
                    nameText: null,
                    massText: null
                });
            }
            console.log(`Generated Asteroid Belt with ${particles.length} particles. Matter Type: ${currentParticleType}`);
            updateParticleCountDisplay(); // Update counter
        }

        // New function: generate a simplified Solar System with inclined orbits
        function generateSolarSystem() {
            clearParticles();

            // Sun
            const sunMass = 5.0e7; // Increased mass for the Sun for better stability
            let sunName = `Sun-${particleIdCounter++}`;
            let sunSphere = BABYLON.MeshBuilder.CreateSphere(sunName, {diameter: 1}, scene);
            sunSphere.position = BABYLON.Vector3.Zero();
            let sunMaterial = new BABYLON.StandardMaterial("sunMat", scene);
            sunMaterial.emissiveColor = new BABYLON.Color3(1, 0.8, 0); // Yellow/Orange for Sun
            sunSphere.material = sunMaterial;
            let sunParticle = {
                name: sunName,
                mesh: sunSphere,
                position: BABYLON.Vector3.Zero(),
                velocity: new BABYLON.Vector3(0, 0, 0),
                mass: sunMass,
                initialDiameter: 1, // Default diameter
                orbitPoints: [BABYLON.Vector3.Zero()],
                orbitMesh: null,
                type: 'matter',
                nameText: null,
                massText: null
            };
            particles.push(sunParticle);
            console.log(`Generated ${sunParticle.name}.`);

            // Planets (simplified) with adjusted distances and inclinations
            const planetsData = [
                { name: "Mercury", distance: 30, mass: 10000, color: new BABYLON.Color3(0.5, 0.5, 0.5), inclinationDeg: 7.0 },
                { name: "Venus", distance: 50, mass: 80000, color: new BABYLON.Color3(0.8, 0.6, 0.2), inclinationDeg: 3.4 },
                { name: "Earth", distance: 70, mass: 100000, color: new BABYLON.Color3(0.1, 0.5, 1), inclinationDeg: 0.0 },
                { name: "Mars", distance: 90, mass: 15000, color: new BABYLON.Color3(0.8, 0.2, 0.1), inclinationDeg: 1.85 },
                { name: "Jupiter", distance: 150, mass: 500000, color: new BABYLON.Color3(0.7, 0.5, 0.3), inclinationDeg: 1.3 },
                { name: "Saturn", distance: 220, mass: 300000, color: new BABYLON.Color3(0.9, 0.8, 0.6), inclinationDeg: 2.5 },
                { name: "Uranus", distance: 280, mass: 40000, color: new BABYLON.Color3(0.4, 0.8, 0.8), inclinationDeg: 0.77 },
                { name: "Neptune", distance: 330, mass: 50000, color: new BABYLON.Color3(0.2, 0.2, 0.8), inclinationDeg: 1.77 }
            ];

            planetsData.forEach(data => {
                // Base position and velocity in a flat XZ plane
                let initialFlatPosition = new BABYLON.Vector3(data.distance, 0, 0);
                let requiredSpeed = Math.sqrt(G_EFFECTIVE * sunMass / data.distance);
                let initialFlatVelocity = new BABYLON.Vector3(0, 0, requiredSpeed); // Velocity along Z for X-position to orbit in XZ

                // Add small random offset to inclination and a random ascending node
                let actualInclination = data.inclinationDeg * Math.PI / 180 + (Math.random() - 0.5) * 0.01; // +/- 0.005 radians (~0.28 degrees)
                let ascendingNode = Math.random() * 2 * Math.PI; // Random angle for ascending node

                // Create rotation quaternion: first rotate around Y-axis (ascendingNode), then X-axis (inclination)
                let rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(ascendingNode, actualInclination, 0);

                // Apply rotation to initial position and velocity vectors
                let position = initialFlatPosition.applyRotationQuaternion(rotationQuaternion);
                let velocity = initialFlatVelocity.applyRotationQuaternion(rotationQuaternion);

                let planetName = `${data.name}-${particleIdCounter++}`;
                let sphere = BABYLON.MeshBuilder.CreateSphere(planetName, {diameter: 1}, scene);
                sphere.position = position;
                
                let material = new BABYLON.StandardMaterial(`${data.name}Mat`, scene);
                material.emissiveColor = data.color;
                sphere.material = material;

                particles.push({
                    name: planetName,
                    mesh: sphere,
                    position: position.clone(),
                    velocity: velocity,
                    mass: data.mass,
                    initialDiameter: 1, // Default diameter
                    orbitPoints: [position.clone()],
                    orbitMesh: null,
                    type: 'matter', // Planets are matter
                    nameText: null,
                    massText: null
                });
                console.log(`Generated ${planetName} with mass ${data.mass.toFixed(0)} at distance ${data.distance}, inclination ${data.inclinationDeg.toFixed(2)} deg.`);
            });

            console.log(`Generated Solar System with ${particles.length} celestial bodies.`);
            updateParticleCountDisplay();
        }

        // Modified setSize to accept an optional particle name, diameter, and color override
        function setSize(mass, particleName = 'ClickParticle', diameter = 1, colorOverride = null) {
            newParticleMass = mass;
            currentParticleDisplayName = particleName;
            newParticleDiameter = diameter; // Set the global diameter
            newParticleColorOverride = colorOverride; // Set the global color override
            document.getElementById("mass").value = mass.toExponential(1).replace("+", "");
            console.log(`New particle type selected: ${currentParticleDisplayName} (Mass: ${newParticleMass.toExponential(1).replace("+", "")}, Diameter: ${newParticleDiameter}, Color/Type Override: ${newParticleColorOverride})`);

            // Adjust camera if a very large/dense object type is selected
            if (particleName === 'Supernova' || particleName === 'Neutron Star' || particleName === 'Black Hole') {
                setCameraZoom(camera.upperRadiusLimit / 2); // Zoom out to half the max radius
                console.log(`Camera zoomed out for ${particleName}.`);
            }
        }
        
        function clearParticles() {
            for (let particle of particles) {
                console.log(`Clearing particle: ${particle.name}`); // Log cleared particle name
                particle.mesh.dispose();
                if (particle.orbitMesh) { // Dispose orbit mesh
                    particle.orbitMesh.dispose();
                }
                // New: Dispose of text labels
                if (particle.nameText) {
                    particle.nameText.dispose();
                }
                if (particle.massText) {
                    particle.massText.dispose();
                }
            }
            particles = [];
            particleIdCounter = 0; // Reset counter when clearing all particles
            console.log("All particles cleared.");
            updateParticleCountDisplay(); // Update counter
        }
        
        function startSimulation() {
            isSimulationRunning = true;
            console.log("Simulation started.");
        }
        
        function stopSimulation() {
            isSimulationRunning = false;
            console.log("Simulation stopped.");
        }

        // Function to toggle orbit visibility
        function toggleOrbits() {
            showOrbits = !showOrbits;
            if (!showOrbits) {
                // If orbits are turned off, dispose all orbit meshes and clear points
                for (let particle of particles) {
                    if (particle.orbitMesh) {
                        particle.orbitMesh.dispose();
                        particle.orbitMesh = null;
                    }
                    particle.orbitPoints = [particle.position.clone()]; // Reset points with current position
                }
                console.log("Orbits hidden.");
            } else {
                // If orbits are turned on, ensure they are created/updated
                updateOrbitMeshes(); 
                console.log("Orbits shown.");
            }
        }

        // New: Function to toggle name visibility
        function toggleNames() {
            showNames = !showNames;
            updateParticleLabels(); // Update visibility for all particles immediately
            console.log("Toggle Name: " + (showNames ? "ON" : "OFF"));
        }

        // New: Function to toggle mass visibility
        function toggleMasses() {
            showMasses = !showMasses;
            updateParticleLabels(); // Update visibility for all particles immediately
            console.log("Toggle Mass: " + (showMasses ? "ON" : "OFF"));
        }

        // Function to add a moon to the most massive particle
        function addMoon() {
            if (particles.length === 0) {
                console.warn("Cannot add a moon: no particles exist to orbit around.");
                return;
            }

            // Find the most massive particle to orbit around
            let parentParticle = particles[0];
            for (let i = 1; i < particles.length; i++) {
                if (particles[i].mass > parentParticle.mass) {
                    parentParticle = particles[i];
                }
            }

            // Random Moon Mass in proportion to the parent particle's mass
            // Between 1% and 11% of parent's mass
            const moonMass = parentParticle.mass * (0.01 + Math.random() * 0.1); 
            // Random Orbit Distance for higher, more exotic orbits
            // Increased range for distance: 10 to 50 units (was 3 to 8)
            const orbitDistance = 10 + Math.random() * 40; 
            
            // Generate a random initial position around the parent
            let randomDirection = new BABYLON.Vector3(
                Math.random() * 2 - 1, // -1 to 1
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize(); // Normalize to get a unit vector

            let moonPosition = parentParticle.position.add(randomDirection.scale(orbitDistance));

            // Calculate tangential velocity for a circular orbit
            let requiredSpeed = Math.sqrt(G_EFFECTIVE * parentParticle.mass / orbitDistance);

            // Direction vector from parent to moon
            let directionToMoon = moonPosition.subtract(parentParticle.position).normalize();
            
            // Generate a more random normal vector for the orbital plane (more exotic orbits)
            let orbitNormal = new BABYLON.Vector3(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize();

            // Ensure orbitNormal is not too close to directionToMoon for cross product stability
            // If they are nearly parallel, choose a different normal (e.g., perpendicular to XZ plane if the direction is mostly XZ)
            if (BABYLON.Vector3.Dot(directionToMoon, orbitNormal) > 0.95 || BABYLON.Vector3.Dot(directionToMoon, orbitNormal) < -0.95) {
                // Try a perpendicular vector in the XZ plane or Y axis
                if (Math.abs(directionToMoon.y) < 0.8) { // If not mostly vertical
                    orbitNormal = new BABYLON.Vector3(0, 1, 0).normalize(); // Use Y-axis as normal
                } else { // If mostly vertical, use X-axis as normal
                    orbitNormal = new BABYLON.Vector3(1, 0, 0).normalize();
                }
            }

            // Calculate tangential direction using cross product (perpendicular to position and orbit normal)
            let tangentialDirection = BABYLON.Vector3.Cross(directionToMoon, orbitNormal).normalize();

            // Randomly choose clockwise or counter-clockwise
            let orbitalDirectionMultiplier = Math.random() < 0.5 ? 1 : -1;
            tangentialDirection.scaleInPlace(orbitalDirectionMultiplier);

            // Adjust for existing parent velocity to ensure relative orbit
            let moonVelocity = parentParticle.velocity.add(tangentialDirection.scale(requiredSpeed));

            let moonName = `Moon-${particleIdCounter++}`;
            // Create the moon particle
            let sphere = BABYLON.MeshBuilder.CreateSphere(moonName, {diameter: 1}, scene);
            sphere.position = moonPosition;
            
            let moonMaterial = new BABYLON.StandardMaterial("moonMat" + particles.length, scene);
            moonMaterial.emissiveColor = getColorByMass(moonMass, currentParticleType); // Use current type
            sphere.material = moonMaterial;
            
            let moonParticle = {
                name: moonName, // Add name property
                mesh: sphere,
                position: moonPosition.clone(),
                velocity: moonVelocity,
                mass: moonMass,
                initialDiameter: 1, // Default diameter
                orbitPoints: [moonPosition.clone()],
                orbitMesh: null,
                type: currentParticleType, // Assign current type
                nameText: null,
                massText: null
            };
            
            particles.push(moonParticle);
            console.log(`Added a ${moonParticle.name} (${moonParticle.type}) with mass ${moonMass.toFixed(0)} orbiting ${parentParticle.name}.`);
            updateParticleCountDisplay(); // Update counter
        }

        // Function to update the particle count display
        function updateParticleCountDisplay() {
            document.getElementById("particleCount").innerText = "Particles: " + particles.length;
        }
    </script>
</body>
</html>
