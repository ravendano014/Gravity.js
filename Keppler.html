<!DOCTYPE html>
<html>
<head>
    <title>Gravity Toy 3D</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            color: #ffffff;
            font-family: 'Courier New', Courier, monospace; /* Changed font to a more common monospace */
            font-size: 11px;
            background-color: black;
        }

        button {
            -webkit-border-radius: 0;
            -moz-border-radius: 0;
            border-radius: 0px;
            font-family: 'Courier New', Courier, monospace;
            color: #ffffff;
            font-size: 11px;
            background: #000000;
            padding: 5px 5px 5px 5px;
            border: solid #ffffff 1px;
            text-decoration: none;
            width: 176px;
            margin-top: 2px;
            cursor: pointer; /* Add cursor pointer for buttons */
        }

        .txt {
            -webkit-border-radius: 0;
            -moz-border-radius: 0;
            border-radius: 0px;
            font-family: 'Courier New', Courier, monospace;
            color: #ffffff;
            font-size: 11px;
            background: #000000;
            padding: 5px 5px 5px 5px;
            border: solid #ffffff 1px;
            text-decoration: none;
            margin-left: 5px;
            width: 50px;
        }

        button:hover {
            background: #ffffff;
            color: #000000;
            text-decoration: none;
        }

        #controlbox {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
            border: solid #ffffff 1px;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            max-height: calc(100vh - 20px); /* Limit height to viewport */
            overflow-y: auto; /* Enable scrolling if content overflows */
        }

        #homebox {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px;
            border: solid #ffffff 1px;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            font-size: 20px;
        }

        /* New: Status Bar Styling */
        #statusbar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            padding: 5px;
            border: solid #ffffff 1px;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        #statusbar div {
            margin: 0 10px;
        }
        #statusbar .txt {
            width: 60px; /* Adjust width for status bar inputs */
            text-align: center;
        }

        a:link {
            color: #0080FF;
            text-decoration: none;
        }

        a:visited {
            color: #0000FF;
            text-decoration: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* Scrollbar styling */
        #controlbox::-webkit-scrollbar {
            width: 6px;
        }
        #controlbox::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        #controlbox::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="controlbox">
        <div>Gravity Toy 3D Controls</div><br>

        <button onclick="toggleMatterType()">Toggle Matter (U)</button><br>

        <div id="particleCount">Particles: 0</div><br>
        <table>
            <tr>
                <td>Mass:</td>
                <td><input type="text" value="1.0e3" class="txt" id="mass" onchange="updateNewParticleMass()"></td>
            </tr>
        </table>
        <br>
        <button onclick="setSize(1, 'Dust')">Dust (0)</button><br>
        <button onclick="setSize(100, 'Tiny')">Tiny (1)</button><br>
        <button onclick="setSize(1000, 'Small')">Small (2)</button><br>
        <button onclick="setSize(10000, 'Medium')">Medium (3)</button><br>
        <button onclick="setSize(100000, 'Huge')">Huge (4)</button><br>
        <button onclick="setSize(1000000, 'Enormous')">Enormous (5)</button><br>
        <button onclick="setSize(300000000 * ( 1 + (Math.random())) , 'Supernova', 0.5, [253, 238, 150])">Supernova</button><br>
        <button onclick="setSize(300000000 * ( 1 + (Math.random())) , 'Neutron Star', 9, 'neutron');">Neutron Star</button><br>
        <button onclick="setSize(1000000000 * ( 1 + (Math.random())) , 'Black Hole', 10, 'blackhole');">Black Hole</button><br>

        <br>
        <button onclick="startSimulation()">Start (S)</button><br>
        <button onclick="stopSimulation()">Stop (s)</button><br>
        <button onclick="generateProto()">Protodisk (D)</button><br>
        <button onclick="generateRandomSystem()">Random System (R)</button><br>
        <button onclick="generateAsteroidBelt()">Asteroid Belt (K)</button><br>
        <button onclick="generateSolarSystem()">Solar System (Y)</button><br>
        <button onclick="clearParticles()">Clear (C)</button><br>
        <button onclick="toggleOrbits()">Toggle Orbits (O)</button><br>
        <button onclick="addMoon()">Add Moon (A)</button><br>
        <button onclick="toggleNames()">Toggle Name (N)</button><br>
        <button onclick="toggleMasses()">Toggle Mass (M)</button><br>
        <br>
        <table>
            <tr><button onclick="setSize(100000000 , 'Sun')">Sun</button></tr> <br>
            <tr><button onclick="setSize(16.6 , 'Mercury')">Mercury</button></tr><br>
            <tr><button onclick="setSize(245 , 'Venus')">Venus</button></tr><br>
            <tr><button onclick="setSize(300 , 'Earth')">Earth</button></tr><br>
            <tr><button onclick="setSize(32.3 , 'Mars')">Mars</button></tr><br>
            <tr><button onclick="setSize(95400 , 'Jupiter')">Jupiter</button></tr><br>
            <tr><button onclick="setSize(28570 , 'Saturn')">Saturn</button></tr><br>
            <tr><button onclick="setSize(4360 , 'Uranus')">Uranus</button></tr><br>
            <tr><button onclick="setSize(5150 , 'Neptune')">Neptune</button></tr><br>
        </table>
    </div>

    <div id="homebox">Gravity Toy 3D</div>

    <canvas id="renderCanvas"></canvas>

    <div id="statusbar">
        <div>
            Speed: <input type="text" id="simulationSpeedInput" class="txt" value="1.0" onchange="setSimulationSpeed(parseFloat(this.value))">
        </div>
        <div>
            Zoom: <input type="text" id="cameraZoomInput" class="txt" value="200" onchange="setCameraZoom(parseFloat(this.value))">
        </div>
        <div>
            Collision Type:
            <select id="collisionTypeSelector" onchange="setCollisionType(this.value)" style="background-color: #000000; color: #ffffff; border: solid #ffffff 1px; font-family: 'Courier New', Courier, monospace; font-size: 11px;">
                <option value="merge">Merge (Default)</option>
                <option value="bounce">Bounce (Elastic)</option>
                <option value="none">None</option>
                <option value="explode">Explode</option>
            </select>
        </div>
    </div>

    <script>
        // Global Variables
        let canvas, engine, scene, camera, light;
        let particles = [];
        let newParticleMass = 1000;
        let currentParticleDisplayName = 'ClickParticle';
        let isSimulationRunning = true;
        let isDragging = false;
        let startX, startY;
        let showOrbits = false;
        let showNames = false;
        let showMasses = false;
        // Optimized orbit rendering parameters
        const ORBIT_POINTS_LIMIT = 200; // Reduced from 500 for shorter trails and less memory
        const ORBIT_DRAW_INTERVAL = 10; // Increased from 5 for less frequent updates, improving performance
        const G_EFFECTIVE = 0.0001; // Gravitational constant adjusted for simulation scale
        let currentParticleType = 'matter'; // Default to matter
        let particleIdCounter = 0; // Counter for unique particle IDs
        let advancedTexture; // For GUI text elements

        // New globals for particle properties when adding
        let newParticleDiameter = 1; // Initial default diameter
        let newParticleColorOverride = null; // Can be an RGB array or a string like 'neutron', 'blackhole'

        // Time and Zoom controls
        let simulationSpeedMultiplier = 1.0;
        let currentCameraZoom = 200;

        // Variables for new particle placement logic
        let isRightMouseDown = false;
        let startPositionForNewParticle = null;
        let velocityLine = null; // Mesh to draw the velocity line

        // New: Collision Type Global
        let currentCollisionType = 'merge'; // 'merge', 'bounce', 'none', 'explode'

        // Function to get a random color
        function getRandomColor() {
            const colors = [
                new BABYLON.Color3(0, 0, 1),      // Blue
                new BABYLON.Color3(0.5, 0, 1),    // Violet
                new BABYLON.Color3(0, 1, 0),      // Green
                new BABYLON.Color3(0.6, 0.4, 0.2),// Brown
                new BABYLON.Color3(1, 0.7, 0.8),  // Pink
                new BABYLON.Color3(1, 1, 0),      // Yellow
                new BABYLON.Color3(1, 0.5, 0)     // Orange
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Helper function for special particle colors (Neutron Star, Black Hole, Supernova)
        function getSpecialColorForType(typeString) {
            switch (typeString) {
                case 'neutron': return new BABYLON.Color3(0.7, 0.7, 1); // Bluish-white
                case 'blackhole': return new BABYLON.Color3(0.05, 0.05, 0.05); // Very dark gray
                case 'supernova': return new BABYLON.Color3(253 / 255, 238 / 255, 150 / 255); // Pale yellow
                default: return new BABYLON.Color3(1, 1, 1); // Default white
            }
        }

        // Initialization of Babylon.js
        window.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 0, 0); // Set background color to black

            // Initialize GUI for text labels
            advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            // Setup camera
            camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 2, 200, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 2000;
            camera.wheelPrecision = 50;
            currentCameraZoom = camera.radius; // Initialize with camera's actual radius
            document.getElementById("cameraZoomInput").value = currentCameraZoom.toFixed(0);

            // Setup light
            light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            // Mouse events
            canvas.addEventListener("pointerdown", function(evt) {
                if (evt.button === 0) { // Left click - Existing behavior (pan/rotate camera)
                    // No change here for camera controls
                } else if (evt.button === 2) { // Right click
                    isRightMouseDown = true;
                    let pickInfo = scene.pick(evt.clientX, evt.clientY);
                    if (pickInfo.hit) {
                        startPositionForNewParticle = pickInfo.pickedPoint.clone();
                    } else {
                        // If no object picked, project a point into the scene
                        let ray = scene.createPickingRay(evt.clientX, evt.clientY, BABYLON.Matrix.Identity(), camera);
                        startPositionForNewParticle = ray.origin.add(ray.direction.scale(currentCameraZoom / 5)); // Place at a distance proportional to zoom
                    }
                    // Prevent context menu on right click
                    evt.preventDefault();
                }
                isDragging = false;
                startX = evt.clientX;
                startY = evt.clientY;
            });

            canvas.addEventListener("pointermove", function(evt) {
                if (isRightMouseDown && startPositionForNewParticle) {
                    if (velocityLine) {
                        velocityLine.dispose();
                    }
                    let currentPickInfo = scene.pick(evt.clientX, evt.clientY);
                    let endPoint;
                    if (currentPickInfo.hit) {
                        endPoint = currentPickInfo.pickedPoint;
                    } else {
                        let ray = scene.createPickingRay(evt.clientX, evt.clientY, BABYLON.Matrix.Identity(), camera);
                        endPoint = ray.origin.add(ray.direction.scale(currentCameraZoom / 5));
                    }
                    velocityLine = BABYLON.MeshBuilder.CreateLines("velocityLine", { points: [startPositionForNewParticle, endPoint] }, scene);
                    velocityLine.color = new BABYLON.Color3(0, 0, 1); // Blue line
                }
                if (Math.abs(evt.clientX - startX) > 5 || Math.abs(evt.clientY - startY) > 5) {
                    isDragging = true;
                }
            });

            canvas.addEventListener("pointerup", function(evt) {
                if (evt.button === 2) { // Right click released
                    isRightMouseDown = false;
                    if (velocityLine) {
                        velocityLine.dispose();
                        velocityLine = null;
                    }

                    if (startPositionForNewParticle) {
                        let endPickInfo = scene.pick(evt.clientX, evt.clientY);
                        let endPoint;
                        if (endPickInfo.hit) {
                            endPoint = endPickInfo.pickedPoint;
                        } else {
                            let ray = scene.createPickingRay(evt.clientX, evt.clientY, BABYLON.Matrix.Identity(), camera);
                            endPoint = ray.origin.add(ray.direction.scale(currentCameraZoom / 5));
                        }

                        let initialVelocity = endPoint.subtract(startPositionForNewParticle).scale(0.1); // Scale velocity to prevent extreme speeds
                        addParticle(startPositionForNewParticle, initialVelocity); // Use the new addParticle signature
                        startPositionForNewParticle = null;
                    }
                }
            });

            // Disable context menu on right-click for the canvas
            canvas.addEventListener("contextmenu", function(e) {
                e.preventDefault();
            });

            // Keyboard events for controls
            window.addEventListener("keydown", function(evt) {
                switch (evt.key) {
                    case "o": case "O": toggleOrbits(); break;
                    case "n": case "N": toggleNames(); break;
                    case "m": case "M": toggleMasses(); break;
                    case "a": case "A": addMoon(); break;
                    case "u": case "U": toggleMatterType(); break;
                    case "y": case "Y": generateSolarSystem(); break;
                    case "1": setSize(100, 'Tiny'); break;
                    case "2": setSize(1000, 'Small'); break;
                    case "3": setSize(10000, 'Medium'); break;
                    case "4": setSize(100000, 'Huge'); break;
                    case "5": setSize(1000000, 'Enormous'); break;
                    case "d": case "D": generateProto(); break;
                    case "k": case "K": generateAsteroidBelt(); break;
                    case "S": startSimulation(); break; // Capital S for Start
                    case "s": stopSimulation(); break;  // Lowercase s for Stop
                    case "c": case "C": clearParticles(); break;
                    case "r": case "R": generateRandomSystem(); break;
                }
            });

            // Start simulation loop
            let frameCount = 0; // Frame counter for orbit drawing
            engine.runRenderLoop(function() {
                if (isSimulationRunning) {
                    updateParticles();
                    frameCount++;
                    if (showOrbits && frameCount % ORBIT_DRAW_INTERVAL === 0) {
                        updateOrbitMeshes();
                    }
                    updateParticleLabels();
                }
                // Update zoom display if camera radius changes due to user interaction
                if (camera.radius !== currentCameraZoom) {
                    currentCameraZoom = camera.radius;
                    document.getElementById("cameraZoomInput").value = currentCameraZoom.toFixed(0);
                }
                scene.render();
            });

            // Handle window resize
            window.addEventListener("resize", function() {
                engine.resize();
            });

            updateParticleCountDisplay(); // Initialize display on load
            updateNewParticleMass(); // Initialize mass input field
        });

        // --- Simulation Control Functions ---

        // Set simulation speed
        function setSimulationSpeed(speed) {
            if (isNaN(speed) || speed <= 0 || speed > 100) {
                alert("Please enter a speed between 0.1 and 100.");
                document.getElementById("simulationSpeedInput").value = simulationSpeedMultiplier.toFixed(1);
            } else {
                simulationSpeedMultiplier = speed;
                document.getElementById("simulationSpeedInput").value = simulationSpeedMultiplier.toFixed(1);
                console.log(`Simulation speed set to: ${simulationSpeedMultiplier}x`);
            }
        }

        // Set camera zoom
        function setCameraZoom(zoom) {
            if (isNaN(zoom) || zoom < camera.lowerRadiusLimit || zoom > camera.upperRadiusLimit) {
                alert(`Please enter a zoom value between ${camera.lowerRadiusLimit} and ${camera.upperRadiusLimit}.`);
                document.getElementById("cameraZoomInput").value = currentCameraZoom.toFixed(0);
            } else {
                camera.radius = zoom;
                currentCameraZoom = zoom;
                document.getElementById("cameraZoomInput").value = currentCameraZoom.toFixed(0);
                console.log(`Camera zoom set to: ${currentCameraZoom}`);
            }
        }

        // New: Set Collision Type
        function setCollisionType(type) {
            currentCollisionType = type;
            console.log(`Collision type set to: ${currentCollisionType}`);
        }

        // Toggle particle type between matter and antimatter
        function toggleMatterType() {
            currentParticleType = (currentParticleType === 'matter') ? 'antimatter' : 'matter';
            console.log(`Particle type toggled to: ${currentParticleType}`);
            // Update the mass input field color to reflect the current type
            const massInput = document.getElementById("mass");
            if (currentParticleType === 'antimatter') {
                massInput.style.color = '#00FFFF'; // Cyan for antimatter
            } else {
                massInput.style.color = '#FFFFFF'; // White for matter
            }
        }

        // Update the new particle mass from the input field
        function updateNewParticleMass() {
            const massValue = parseFloat(document.getElementById("mass").value);
            if (isNaN(massValue) || massValue <= 0) {
                alert("Please enter a valid positive number for mass.");
                document.getElementById("mass").value = newParticleMass.toExponential(1).replace("+", ""); // Revert to last valid
            } else {
                newParticleMass = massValue;
                document.getElementById("mass").value = newParticleMass.toExponential(1).replace("+", "");
                console.log(`New particle mass set to: ${newParticleMass.toExponential(1)}`);
            }
        }

        // Function to get color based on mass and type (still used for non-random system particles)
        function getColorByMass(mass, type) {
            let color;
            if (type === 'antimatter') {
                if (mass < 500) color = new BABYLON.Color3(0.5, 0.5, 1);    // Light Blue
                else if (mass < 5000) color = new BABYLON.Color3(0.3, 0.3, 1); // Medium Blue
                else if (mass < 50000) color = new BABYLON.Color3(0.1, 0.1, 1); // Dark Blue
                else color = new BABYLON.Color3(0, 0, 0.8);                  // Very Dark Blue
            } else { // Matter
                if (mass < 500) color = new BABYLON.Color3(1, 1, 1);     // White
                else if (mass < 5000) color = new BABYLON.Color3(1, 1, 0);    // Yellow
                else if (mass < 50000) color = new BABYLON.Color3(1, 0.5, 0); // Orange
                else color = new BABYLON.Color3(1, 0, 0);                    // Red
            }
            return color;
        }

        // --- Core Simulation Logic ---
        function updateParticles() {
            let particlesToRemove = new Set();
            let newParticlesToAdd = []; // To store fragments from explosions

            // Apply gravity and handle collisions
            for (let i = 0; i < particles.length; i++) {
                if (particlesToRemove.has(particles[i])) continue; // Skip if already marked for removal

                let p1 = particles[i];
                let totalForce = new BABYLON.Vector3(0, 0, 0);

                for (let j = 0; j < particles.length; j++) {
                    if (i === j || particlesToRemove.has(particles[j])) continue; // Skip self or already marked for removal

                    let p2 = particles[j];

                    let direction = p2.position.subtract(p1.position);
                    let distanceSquared = direction.lengthSquared();
                    let distance = Math.sqrt(distanceSquared);

                    // Collision detection based on current mesh scaling (radius = diameter / 2).
                    // We use mesh scaling directly as it reflects the visual size.
                    let radius1 = p1.mesh.scaling.x / 2; // Assuming sphere scaling is uniform
                    let radius2 = p2.mesh.scaling.x / 2;
                    let collisionThreshold = radius1 + radius2;

                    if (distance < collisionThreshold && distance > 0.01) { // Collision detected, add a small epsilon to avoid div by zero if objects perfectly overlap
                        console.log(`Collision detected between ${p1.name} (${p1.type}, ${p1.mass.toFixed(0)}) and ${p2.name} (${p2.type}, ${p2.mass.toFixed(0)})`);

                        if (currentCollisionType === 'none') {
                            // Do nothing, particles pass through
                            console.log("Collision ignored due to 'None' collision type.");
                        } else if (p1.type === 'blackhole' || p2.type === 'blackhole') {
                            // If any is a black hole, they merge into a larger black hole
                            let blackHole = (p1.type === 'blackhole') ? p1 : p2;
                            let absorbed = (p1.type === 'blackhole') ? p2 : p1;

                            if (blackHole === p1) { // p1 absorbs p2
                                p1.mass += p2.mass;
                                // Conserve momentum
                                p1.velocity = p1.velocity.scale(p1.mass - p2.mass).add(p2.velocity.scale(p2.mass)).scale(1 / p1.mass);
                                particlesToRemove.add(absorbed);
                            } else { // p2 absorbs p1
                                p2.mass += p1.mass;
                                p2.velocity = p2.velocity.scale(p2.mass - p1.mass).add(p1.velocity.scale(p1.mass)).scale(1 / p2.mass);
                                particlesToRemove.add(absorbed);
                            }
                            console.log(`Black Hole merger: New mass for surviving black hole: ${blackHole.mass.toFixed(0)}`);

                        } else if (p1.type !== p2.type) { // Matter-Antimatter collision
                            let remainingMass = Math.abs(p1.mass - p2.mass);

                            if (remainingMass > 0) {
                                // The more massive particle survives with reduced mass
                                let survivor = p1.mass > p2.mass ? p1 : p2;
                                let absorbed = p1.mass > p2.mass ? p2 : p1;

                                survivor.mass = remainingMass;
                                survivor.mesh.material.emissiveColor = getColorByMass(survivor.mass, survivor.type);
                                particlesToRemove.add(absorbed);
                                console.log(`Matter-Antimatter: ${absorbed.name} annihilated. ${survivor.name} (${survivor.type}) with ${survivor.mass.toFixed(0)} remains.`);

                            } else { // Masses are equal, both annihilated
                                particlesToRemove.add(p1);
                                particlesToRemove.add(p2);
                                console.log(`Matter-Antimatter: Both ${p1.name} and ${p2.name} of mass ${p1.mass.toFixed(0)} annihilated.`);
                            }
                        } else { // Matter-Matter or Antimatter-Antimatter collision
                            if (currentCollisionType === 'merge') {
                                let mergedMass = p1.mass + p2.mass;

                                // Conserve momentum
                                let mergedVelocity = p1.velocity.scale(p1.mass).add(p2.velocity.scale(p2.mass)).scale(1 / mergedMass);

                                p1.mass = mergedMass;
                                p1.velocity = mergedVelocity;
                                p1.mesh.material.emissiveColor = getColorByMass(p1.mass, p1.type);
                                particlesToRemove.add(p2); // Mark the second particle for removal
                                console.log(`${p1.type}-${p1.type}: ${p1.name} merged with ${p2.name}. New mass: ${p1.mass.toFixed(0)}`);
                            } else if (currentCollisionType === 'bounce') {
                                // Elastic collision (simplified)
                                // Calculate relative velocity
                                let vRel = p1.velocity.subtract(p2.velocity);
                                let normal = direction.normalize();

                                // Velocity component along the normal
                                let vRelNormal = BABYLON.Vector3.Dot(vRel, normal);

                                // If particles are moving apart, no collision (or already handled)
                                if (vRelNormal > 0) continue;

                                // Impulse magnitude (2 * reduced mass * vRelNormal / (p1.mass + p2.mass))
                                let impulse = -2 * vRelNormal / (1/p1.mass + 1/p2.mass);

                                // Apply impulse
                                p1.velocity.addInPlace(normal.scale(impulse / p1.mass));
                                p2.velocity.subtractInPlace(normal.scale(impulse / p2.mass));

                                console.log(`${p1.type}-${p1.type}: ${p1.name} bounced off ${p2.name}.`);

                                // Simple repositioning to avoid sticking
                                let overlap = collisionThreshold - distance;
                                if (overlap > 0) {
                                    let separationVector = normal.scale(overlap / 2);
                                    p1.position.addInPlace(separationVector);
                                    p2.position.subtractInPlace(separationVector);
                                }
                            } else if (currentCollisionType === 'explode') {
                                console.log(`${p1.type}-${p1.type}: ${p1.name} exploded with ${p2.name}.`);

                                // Mark both particles for removal
                                particlesToRemove.add(p1);
                                particlesToRemove.add(p2);

                                // Calculate combined mass for new fragments
                                let combinedMass = p1.mass + p2.mass;
                                let collisionPoint = p1.position.add(p2.position).scale(0.5); // Midpoint of collision

                                // Generate multiple smaller fragments
                                const numFragments = 5 + Math.floor(Math.random() * 5); // 5 to 9 fragments
                                for (let k = 0; k < numFragments; k++) {
                                    let fragmentMass = combinedMass * (0.05 + Math.random() * 0.15); // 5-20% of combined mass
                                    if (fragmentMass < 10) fragmentMass = 10; // Ensure a minimum mass for visibility/effect

                                    // Random direction for explosion
                                    let randomExplosionDirection = new BABYLON.Vector3(
                                        Math.random() * 2 - 1,
                                        Math.random() * 2 - 1,
                                        Math.random() * 2 - 1
                                    ).normalize();

                                    // Random initial speed for fragments
                                    let explosionSpeed = 0.5 + Math.random() * 1.5;

                                    // Apply explosion force as an initial velocity to fragments
                                    let fragmentVelocity = randomExplosionDirection.scale(explosionSpeed);

                                    let fragmentName = `Fragment-${particleIdCounter++}`;
                                    let fragmentSphere = BABYLON.MeshBuilder.CreateSphere(fragmentName, {diameter: newParticleDiameter}, scene); // Changed here
                                    fragmentSphere.position = collisionPoint.add(randomExplosionDirection.scale(0.5)); // Start slightly offset

                                    let fragmentMaterial = new BABYLON.StandardMaterial("fragmentMat" + particleIdCounter, scene);
                                    // Fragments get a random color, or a color related to the original particles
                                    if (p1.type === p2.type) { // If same type, use original color with variation
                                        fragmentMaterial.emissiveColor = p1.mesh.material.emissiveColor.add(new BABYLON.Color3(Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1));
                                    } else { // If matter-antimatter, perhaps a neutral or burst color
                                        fragmentMaterial.emissiveColor = new BABYLON.Color3(1, Math.random(), 0); // Fiery color
                                    }
                                    fragmentSphere.material = fragmentMaterial;

                                    let fragment = {
                                        name: fragmentName,
                                        mesh: fragmentSphere,
                                        position: fragmentSphere.position.clone(),
                                        velocity: fragmentVelocity,
                                        mass: fragmentMass,
                                        initialDiameter: newParticleDiameter, // Store diameter for fragments too
                                        orbitPoints: [fragmentSphere.position.clone()],
                                        orbitMesh: null,
                                        type: p1.type, // Fragments inherit type of the first particle for consistency
                                        nameText: null,
                                        massText: null
                                    };
                                    newParticlesToAdd.push(fragment); // Add new fragments to a temporary array
                                    console.log(`  - Added fragment ${fragment.name} with mass ${fragmentMass.toFixed(0)}`);
                                }
                            }
                        }
                    }

                    // Apply gravitational force
                    if (distanceSquared > 0.1) { // Avoid division by zero for gravity calculation, and prevent extreme forces at very close distances
                        let forceMagnitude = (p1.mass * p2.mass) / distanceSquared;
                        direction.normalize();
                        totalForce.addInPlace(direction.scale(forceMagnitude * G_EFFECTIVE));
                    }
                }

                // Update velocity (F = ma => a = F/m)
                if (p1.mass > 0) { // Only update if particle still has mass
                    p1.velocity.addInPlace(totalForce.scale(1 / p1.mass));
                }
            }

            // Remove particles marked for removal
            let finalParticles = [];
            for (let particle of particles) {
                if (!particlesToRemove.has(particle)) {
                    finalParticles.push(particle);
                } else {
                    console.log(`Disposing of particle: ${particle.name}`);
                    particle.mesh.dispose();
                    if (particle.orbitMesh) {
                        particle.orbitMesh.dispose();
                    }
                    if (particle.nameText) {
                        particle.nameText.dispose();
                    }
                    if (particle.massText) {
                        particle.massText.dispose();
                    }
                }
            }
            particles = finalParticles.concat(newParticlesToAdd); // Add newly created fragments

            // Update positions and sizes of remaining particles
            for (let particle of particles) {
                if (particle.mass <= 0) { // Should ideally be caught by removal, but as a safeguard
                    particlesToRemove.add(particle);
                    continue;
                }
                particle.position.addInPlace(particle.velocity.scale(simulationSpeedMultiplier));
                particle.mesh.position.copyFrom(particle.position);

                // Update size based on mass (logarithmic for better visualization)
                let scale = Math.log10(particle.mass + 1) / 3; // Adjusted scale factor for better visual range
                if (scale < 0.2) scale = 0.2; // Minimum size for visibility

                // For Black Holes, use the initial diameter if provided, otherwise scale by mass
                if (particle.type === 'blackhole' && particle.initialDiameter) {
                    particle.mesh.scaling.set(particle.initialDiameter, particle.initialDiameter, particle.initialDiameter);
                } else {
                    particle.mesh.scaling.set(scale, scale, scale);
                }

                // Add current position to orbit points
                particle.orbitPoints.push(particle.position.clone());
                if (particle.orbitPoints.length > ORBIT_POINTS_LIMIT) {
                    particle.orbitPoints.shift(); // Remove the oldest point
                }
            }
            updateParticleCountDisplay();
        }

        // Update orbit meshes
        function updateOrbitMeshes() {
            for (let particle of particles) {
                if (showOrbits) {
                    if (particle.orbitPoints.length > 1) { // Only draw if there are at least two points
                        if (particle.orbitMesh) {
                            // Update existing line mesh
                            BABYLON.MeshBuilder.CreateLines("orbitLines", {points: particle.orbitPoints, instance: particle.orbitMesh}, scene);
                        } else {
                            // Create new line mesh
                            particle.orbitMesh = BABYLON.MeshBuilder.CreateLines("orbitLines", {points: particle.orbitPoints, updatable: true}, scene);
                            particle.orbitMesh.color = particle.mesh.material.emissiveColor; // Match orbit color to particle color
                        }
                    }
                } else {
                    // If orbits are not shown, dispose of the mesh
                    if (particle.orbitMesh) {
                        particle.orbitMesh.dispose();
                        particle.orbitMesh = null;
                    }
                }
            }
        }

        // Update particle labels (name and mass)
        function updateParticleLabels() {
            for (let particle of particles) {
                if (!particle.nameText) {
                    particle.nameText = new BABYLON.GUI.TextBlock();
                    particle.nameText.color = "white";
                    particle.nameText.fontSize = 10;
                    advancedTexture.addControl(particle.nameText);
                    particle.nameText.linkWithMesh(particle.mesh);
                    particle.nameText.linkOffsetY = -30;
                }

                if (!particle.massText) {
                    particle.massText = new BABYLON.GUI.TextBlock();
                    particle.massText.color = "lightgray";
                    particle.massText.fontSize = 9;
                    advancedTexture.addControl(particle.massText);
                    particle.massText.linkWithMesh(particle.mesh);
                    particle.massText.linkOffsetY = -15;
                }

                particle.nameText.isVisible = showNames;
                particle.massText.isVisible = showMasses;

                if (showNames) {
                    particle.nameText.text = particle.name;
                }
                if (showMasses) {
                    particle.massText.text = `Mass: ${particle.mass.toExponential(1).replace("+", "")}`;
                }
            }
        }

        // Modified addParticle function to accept position and velocity
        function addParticle(position, velocity) {
            let particleName = `${currentParticleDisplayName || 'ClickParticle'}-${particleIdCounter++}`;
            let sphere = BABYLON.MeshBuilder.CreateSphere(particleName, {diameter: newParticleDiameter}, scene); // Modified diameter here for consistency
            sphere.position = position;

            let particleMaterial = new BABYLON.StandardMaterial("particleMat" + particles.length, scene);

            if (typeof newParticleColorOverride === 'string') {
                particleMaterial.emissiveColor = getSpecialColorForType(newParticleColorOverride);
            } else if (Array.isArray(newParticleColorOverride)) {
                particleMaterial.emissiveColor = new BABYLON.Color3(
                    newParticleColorOverride[0] / 255,
                    newParticleColorOverride[1] / 255,
                    newParticleColorOverride[2] / 255
                );
            } else {
                particleMaterial.emissiveColor = getColorByMass(newParticleMass, currentParticleType);
            }
            sphere.material = particleMaterial;

            let particle = {
                name: particleName,
                mesh: sphere,
                position: position.clone(),
                velocity: velocity, // Use the provided velocity
                mass: newParticleMass,
                initialDiameter: newParticleDiameter, // Store reduced diameter
                orbitPoints: [position.clone()],
                orbitMesh: null,
                type: currentParticleType,
                nameText: null,
                massText: null
            };

            particles.push(particle);
            console.log(`Added particle ${particle.name} (${particle.type}) with mass ${newParticleMass.toFixed(0)} and velocity ${velocity.length().toFixed(2)}`);
            updateParticleCountDisplay();
        }

        function generateProto() {
            // clearParticles(); // Removed this line to allow incremental addition

            // Add a massive central particle (always matter) if it doesn't exist
            let centralParticle = particles.find(p => p.name.startsWith('CentralStar'));
            if (!centralParticle) {
                let centralMass = 1.0e6; // Increased central mass for stronger pull
                let centralParticleName = `CentralStar-${particleIdCounter++}`;
                let centralSphere = BABYLON.MeshBuilder.CreateSphere(centralParticleName, {diameter: 1 * 0.5 * 0.5}, scene);
                centralSphere.position = BABYLON.Vector3.Zero();

                let centralMaterial = new BABYLON.StandardMaterial("centralMat", scene);
                centralMaterial.emissiveColor = new BABYLON.Color3(1, 0.8, 0); // Sun-like color
                centralSphere.material = centralMaterial;

                centralParticle = {
                    name: centralParticleName,
                    mesh: centralSphere,
                    position: BABYLON.Vector3.Zero(),
                    velocity: new BABYLON.Vector3(0, 0, 0),
                    mass: centralMass,
                    initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                    orbitPoints: [BABYLON.Vector3.Zero()],
                    orbitMesh: null,
                    type: 'matter',
                    nameText: null,
                    massText: null
                };
                particles.push(centralParticle);
                console.log(`Generated central particle ${centralParticle.name}.`);
            }


            // Create a protoplanetary disk of particles
            const numProtoParticles = 500;
            const minRadius = 0;
            const maxRadius = 25; // Further reduced for "aun más cerca"
            const verticalSpread = 2; // Kept for 3D realism

            for (let i = 0; i < numProtoParticles; i++) {
                let randRadius = minRadius + (Math.random() * (maxRadius - minRadius));
                let randAngle = Math.random() * 2 * Math.PI;
                let z = (Math.random() - 0.5) * verticalSpread; // Spread along the Y-axis (Babylon's up)

                // Position adapted for Babylon.js (XZ plane for disk)
                let initialPosition = new BABYLON.Vector3(randRadius * Math.cos(randAngle), z, randRadius * Math.sin(randAngle));

                let mass = 1000 + Math.random() * 500; // Varying mass for protoplanets

                let distance = initialPosition.subtract(centralParticle.position).length();
                let orbitalSpeed = 0;
                if (distance > 0.01) { // Prevent division by zero if distance is too small
                    orbitalSpeed = Math.sqrt(G_EFFECTIVE * centralParticle.mass / distance);
                }


                let directionFromCenter = initialPosition.subtract(centralParticle.position).normalize();

                // Keep the orbital plane mostly flat (around Y axis for Babylon.js)
                let orbitNormal = new BABYLON.Vector3(0, 1, 0);

                let tangentialDirection = BABYLON.Vector3.Cross(directionFromCenter, orbitNormal).normalize();

                // Apply velocity, considering the central particle's velocity (though it's 0)
                let velocity = centralParticle.velocity.add(tangentialDirection.scale(orbitalSpeed));

                let protoParticleName = `ProtoParticle-${particleIdCounter++}`;
                let sphere = BABYLON.MeshBuilder.CreateSphere(protoParticleName, {diameter: 1 * 0.5 * 0.5}, scene);
                sphere.position = initialPosition;

                let particleMaterial = new BABYLON.StandardMaterial("protoParticleMat" + i, scene);
                particleMaterial.emissiveColor = getRandomColor(); // Use random colors for disk particles
                sphere.material = particleMaterial;

                particles.push({
                    name: protoParticleName,
                    mesh: sphere,
                    position: initialPosition.clone(),
                    velocity: velocity,
                    mass: mass,
                    initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                    orbitPoints: [initialPosition.clone()],
                    orbitMesh: null,
                    type: 'matter',
                    nameText: null,
                    massText: null
                });
            }
            console.log(`Generated Protodisk with ${particles.length} particles. Matter Type: ${currentParticleType}`);
            updateParticleCountDisplay();
        }

        // Generate a more stable random system with colored particles
        function generateRandomSystem() {
            clearParticles(); // This function still clears all particles as per previous behavior.

            // 1. Create a very massive central body (always matter)
            const centralMass = 5.0e7;
            let centralSystemBodyName = `SystemCenter-${particleIdCounter++}`;
            let centralSphere = BABYLON.MeshBuilder.CreateSphere(centralSystemBodyName, {diameter: 1 * 0.5 * 0.5}, scene);
            centralSphere.position = BABYLON.Vector3.Zero();
            let centralMaterial = new BABYLON.StandardMaterial("centralSystemMat", scene);
            centralMaterial.emissiveColor = new BABYLON.Color3(1, 0.8, 0);
            centralSphere.material = centralMaterial;
            let centralParticle = {
                name: centralSystemBodyName,
                mesh: centralSphere,
                position: BABYLON.Vector3.Zero(),
                velocity: new BABYLON.Vector3(0, 0, 0),
                mass: centralMass,
                initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                orbitPoints: [BABYLON.Vector3.Zero()],
                orbitMesh: null,
                type: 'matter',
                nameText: null,
                massText: null
            };
            particles.push(centralParticle);
            console.log(`Generated central system body ${centralParticle.name}.`);

            // 2. Generate orbiting "planets" or "moons"
            const numPlanets = 10 + Math.floor(Math.random() * 20);
            const innerOrbitRadius = 30;
            const outerOrbitRadius = 150;
            const orbitalPlaneSpread = 10; // Increased spread for more varied orbits

            for (let i = 0; i < numPlanets; i++) {
                let randomRadius = innerOrbitRadius + (Math.random() * (outerOrbitRadius - innerOrbitRadius));
                let randomAngle = Math.random() * 2 * Math.PI;
                let randomHeight = (Math.random() - 0.5) * orbitalPlaneSpread; // Vertical spread for inclinations

                let position = new BABYLON.Vector3(
                    randomRadius * Math.cos(randomAngle),
                    randomHeight,
                    randomRadius * Math.sin(randomAngle)
                );

                let mass = 1000 + Math.random() * 99000;

                let distance = position.subtract(centralParticle.position).length();
                let orbitalSpeed = Math.sqrt(G_EFFECTIVE * centralParticle.mass / distance);

                let directionFromCenter = position.subtract(centralParticle.position).normalize();

                // Randomize orbit normal for varied inclinations
                let orbitNormal = new BABYLON.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                ).normalize();
                // Ensure orbitNormal is not too close to directionFromCenter
                if (BABYLON.Vector3.Dot(directionFromCenter, orbitNormal) > 0.9 || BABYLON.Vector3.Dot(directionFromCenter, orbitNormal) < -0.9) {
                    orbitNormal = BABYLON.Vector3.Cross(directionFromCenter, BABYLON.Vector3.Up()).normalize();
                    if (orbitNormal.lengthSquared() < 0.001) orbitNormal = BABYLON.Vector3.Cross(directionFromCenter, BABYLON.Vector3.Right()).normalize();
                }

                let tangentialDirection = BABYLON.Vector3.Cross(directionFromCenter, orbitNormal).normalize();

                let orbitalDirectionMultiplier = Math.random() < 0.5 ? 1 : -1;
                tangentialDirection.scaleInPlace(orbitalDirectionMultiplier);

                let velocity = centralParticle.velocity.add(tangentialDirection.scale(orbitalSpeed));

                let planetName = `Planet-${particleIdCounter++}`;
                let sphere = BABYLON.MeshBuilder.CreateSphere(planetName, {diameter: 1 * 0.5 * 0.5}, scene);
                sphere.position = position;

                let particleMaterial = new BABYLON.StandardMaterial("planetMat" + i, scene);
                particleMaterial.emissiveColor = getRandomColor();
                sphere.material = particleMaterial;

                particles.push({
                    name: planetName,
                    mesh: sphere,
                    position: position.clone(),
                    velocity: velocity,
                    mass: mass,
                    initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                    orbitPoints: [position.clone()],
                    orbitMesh: null,
                    type: currentParticleType,
                    nameText: null,
                    massText: null
                });
            }
            console.log(`Generated Random System with ${particles.length} particles. Matter Type: ${currentParticleType}`);
            updateParticleCountDisplay();
        }

        // Function to generate an asteroid belt
        function generateAsteroidBelt() {
            // clearParticles(); // Removed this line to allow incremental addition

            // Create a central, massive body (always matter for belt) if it doesn't exist
            let centralParticle = particles.find(p => p.name.startsWith('CentralMass'));
            if (!centralParticle) {
                let centralMass = 1.5e5;
                let centralAsteroidBodyName = `CentralMass-${particleIdCounter++}`;
                let centralSphere = BABYLON.MeshBuilder.CreateSphere(centralAsteroidBodyName, {diameter: 1 * 0.5 * 0.5}, scene);
                centralSphere.position = BABYLON.Vector3.Zero();
                let centralMaterial = new BABYLON.StandardMaterial("centralAsteroidMat", scene);
                centralMaterial.emissiveColor = new BABYLON.Color3(0.7, 0.7, 0.7); // Grayish color for central asteroid body
                centralSphere.material = centralMaterial;
                centralParticle = {
                    name: centralAsteroidBodyName,
                    mesh: centralSphere,
                    position: BABYLON.Vector3.Zero(),
                    velocity: new BABYLON.Vector3(0, 0, 0),
                    mass: centralMass,
                    initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                    orbitPoints: [BABYLON.Vector3.Zero()],
                    orbitMesh: null,
                    type: 'matter',
                    nameText: null,
                    massText: null
                };
                particles.push(centralParticle);
                console.log(`Generated central asteroid body ${centralParticle.name}.`);
            }


            const numAsteroids = 500;
            const innerRadius = 50;
            const outerRadius = 90;
            const beltThickness = 5;

            for (let i = 0; i < numAsteroids; i++) {
                let randomRadius = innerRadius + (Math.random() * (outerRadius - innerRadius));
                let randomAngle = Math.random() * 2 * Math.PI;
                let randomHeight = (Math.random() - 0.5) * beltThickness;

                let position = new BABYLON.Vector3(
                    randomRadius * Math.cos(randomAngle),
                    randomHeight,
                    randomRadius * Math.sin(randomAngle)
                );

                let mass = 50 + Math.random() * 950;

                let distance = position.subtract(centralParticle.position).length();
                let orbitalSpeed = Math.sqrt(G_EFFECTIVE * centralParticle.mass / distance);

                let directionFromCenter = position.subtract(centralParticle.position).normalize();

                // Introduce slight randomness for orbital plane for a more chaotic belt
                let orbitNormal = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    1 + (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                ).normalize();
                if (BABYLON.Vector3.Dot(directionFromCenter, orbitNormal) > 0.95) {
                    orbitNormal = new BABYLON.Vector3(1, 0, 0).normalize();
                }

                let tangentialDirection = BABYLON.Vector3.Cross(directionFromCenter, orbitNormal).normalize();

                let orbitalDirectionMultiplier = Math.random() < 0.5 ? 1 : -1;
                tangentialDirection.scaleInPlace(orbitalDirectionMultiplier);

                let velocity = centralParticle.velocity.add(tangentialDirection.scale(orbitalSpeed));

                let asteroidName = `Asteroid-${particleIdCounter++}`;
                let sphere = BABYLON.MeshBuilder.CreateSphere(asteroidName, {diameter: 1 * 0.5 * 0.5}, scene);
                sphere.position = position;

                let particleMaterial = new BABYLON.StandardMaterial("asteroidMat" + i, scene);
                // Asteroids typically brownish/grayish colors
                particleMaterial.emissiveColor = new BABYLON.Color3(0.5 + Math.random() * 0.2, 0.3 + Math.random() * 0.2, 0.1 + Math.random() * 0.2);
                sphere.material = particleMaterial;

                particles.push({
                    name: asteroidName,
                    mesh: sphere,
                    position: position.clone(),
                    velocity: velocity,
                    mass: mass,
                    initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                    orbitPoints: [position.clone()],
                    orbitMesh: null,
                    type: currentParticleType,
                    nameText: null,
                    massText: null
                });
            }
            console.log(`Generated Asteroid Belt with ${particles.length} particles. Matter Type: ${currentParticleType}`);
            updateParticleCountDisplay();
        }

        // Generate a simplified Solar System with inclined orbits
        function generateSolarSystem() {
            clearParticles();

            // Sun
            const sunMass = 5.0e7;
            let sunName = `Sun-${particleIdCounter++}`;
            let sunSphere = BABYLON.MeshBuilder.CreateSphere(sunName, {diameter: 1 * 0.5 * 0.5}, scene);
            sunSphere.position = BABYLON.Vector3.Zero();
            let sunMaterial = new BABYLON.StandardMaterial("sunMat", scene);
            sunMaterial.emissiveColor = new BABYLON.Color3(1, 0.8, 0);
            sunSphere.material = sunMaterial;
            let sunParticle = {
                name: sunName,
                mesh: sunSphere,
                position: BABYLON.Vector3.Zero(),
                velocity: new BABYLON.Vector3(0, 0, 0),
                mass: sunMass,
                initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                orbitPoints: [BABYLON.Vector3.Zero()],
                orbitMesh: null,
                type: 'matter',
                nameText: null,
                massText: null
            };
            particles.push(sunParticle);
            console.log(`Generated ${sunParticle.name}.`);

            // Planets (simplified) with adjusted distances and inclinations
            // Inclinations are relative to the ecliptic (XZ plane in this setup)
            const planetsData = [
                { name: "Mercury", distance: 30, mass: 10000, color: new BABYLON.Color3(0.5, 0.5, 0.5), inclinationDeg: 7.0 },
                { name: "Venus", distance: 50, mass: 80000, color: new BABYLON.Color3(0.8, 0.6, 0.2), inclinationDeg: 3.4 },
                { name: "Earth", distance: 70, mass: 100000, color: new BABYLON.Color3(0.1, 0.5, 1), inclinationDeg: 0.0 },
                { name: "Mars", distance: 90, mass: 15000, color: new BABYLON.Color3(0.8, 0.2, 0.1), inclinationDeg: 1.85 },
                { name: "Jupiter", distance: 150, mass: 500000, color: new BABYLON.Color3(0.7, 0.5, 0.3), inclinationDeg: 1.3 },
                { name: "Saturn", distance: 220, mass: 300000, color: new BABYLON.Color3(0.9, 0.8, 0.6), inclinationDeg: 2.5 },
                { name: "Uranus", distance: 280, mass: 43600, color: new BABYLON.Color3(0.4, 0.8, 0.8), inclinationDeg: 0.77 },
                { name: "Neptune", distance: 330, mass: 51500, color: new BABYLON.Color3(0.2, 0.2, 0.8), inclinationDeg: 1.77 }
            ];

            planetsData.forEach(data => {
                // Base position in XZ plane
                let initialFlatPosition = new BABYLON.Vector3(data.distance, 0, 0);
                // Required speed for circular orbit in XZ plane
                let requiredSpeed = Math.sqrt(G_EFFECTIVE * sunMass / data.distance);
                let initialFlatVelocity = new BABYLON.Vector3(0, 0, requiredSpeed);

                // Convert inclination to radians
                let actualInclination = data.inclinationDeg * Math.PI / 180;
                // Random angle for ascending node (where the orbit crosses the reference plane going "up")
                let ascendingNode = Math.random() * 2 * Math.PI;

                // Create rotation quaternion: first rotate around Y-axis (ascendingNode), then X-axis (inclination)
                // This correctly applies inclination relative to the XZ plane after an arbitrary rotation
                let rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(ascendingNode, actualInclination, 0);

                // Apply rotation to initial position and velocity vectors
                let position = initialFlatPosition.applyRotationQuaternion(rotationQuaternion);
                let velocity = initialFlatVelocity.applyRotationQuaternion(rotationQuaternion);

                let planetName = `${data.name}-${particleIdCounter++}`;
                let sphere = BABYLON.MeshBuilder.CreateSphere(planetName, {diameter: 1 * 0.5 * 0.5}, scene);
                sphere.position = position;

                let material = new BABYLON.StandardMaterial(`${data.name}Mat`, scene);
                material.emissiveColor = data.color;
                sphere.material = material;

                particles.push({
                    name: planetName,
                    mesh: sphere,
                    position: position.clone(),
                    velocity: velocity,
                    mass: data.mass,
                    initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                    orbitPoints: [position.clone()],
                    orbitMesh: null,
                    type: 'matter',
                    nameText: null,
                    massText: null
                });
                console.log(`Generated ${planetName} with mass ${data.mass.toFixed(0)} at distance ${data.distance}, inclination ${data.inclinationDeg.toFixed(2)} deg.`);
            });

            console.log(`Generated Solar System with ${particles.length} celestial bodies.`);
            updateParticleCountDisplay();
        }

        // Set properties for the next particle to be added (e.g., by clicking)
        function setSize(mass, particleName = 'ClickParticle', diameter = 1, colorOverride = null) {
            newParticleMass = mass;
            currentParticleDisplayName = particleName;
            newParticleDiameter = diameter * 0.5 * 0.5; // Diameter is 25% of the base diameter
            newParticleColorOverride = colorOverride;
            document.getElementById("mass").value = mass.toExponential(1).replace("+", "");
            console.log(`New particle type selected: ${currentParticleDisplayName} (Mass: ${newParticleMass.toExponential(1).replace("+", "")}, Diameter: ${newParticleDiameter}, Color/Type Override: ${colorOverride ? (Array.isArray(colorOverride) ? `RGB(${colorOverride.join(',')})` : colorOverride) : 'N/A'})`);

            // Adjust camera if a very large/dense object type is selected
            if (particleName === 'Supernova' || particleName === 'Neutron Star' || particleName === 'Black Hole') {
                setCameraZoom(camera.upperRadiusLimit / 2);
                console.log(`Camera zoomed out for ${particleName}.`);
            }
        }

        // Clear all particles from the simulation
        function clearParticles() {
            for (let particle of particles) {
                console.log(`Clearing particle: ${particle.name}`);
                particle.mesh.dispose();
                if (particle.orbitMesh) {
                    particle.orbitMesh.dispose();
                }
                if (particle.nameText) {
                    particle.nameText.dispose();
                }
                if (particle.massText) {
                    particle.massText.dispose();
                }
            }
            particles = [];
            particleIdCounter = 0; // Reset counter
            console.log("All particles cleared.");
            updateParticleCountDisplay();
        }

        // Start the simulation
        function startSimulation() {
            isSimulationRunning = true;
            console.log("Simulation started.");
        }

        // Stop the simulation
        function stopSimulation() {
            isSimulationRunning = false;
            console.log("Simulation stopped.");
        }

        // Toggle orbit visibility
        function toggleOrbits() {
            showOrbits = !showOrbits;
            if (!showOrbits) {
                for (let particle of particles) {
                    if (particle.orbitMesh) {
                        particle.orbitMesh.dispose();
                    }
                    particle.orbitPoints = [particle.position.clone()]; // Reset points with current position
                }
                console.log("Orbits hidden.");
            } else {
                updateOrbitMeshes();
                console.log("Orbits shown.");
            }
        }

        // Toggle name visibility
        function toggleNames() {
            showNames = !showNames;
            updateParticleLabels();
            console.log("Toggle Name: " + (showNames ? "ON" : "OFF"));
        }

        // Toggle mass visibility
        function toggleMasses() {
            showMasses = !showMasses;
            updateParticleLabels();
            console.log("Toggle Mass: " + (showMasses ? "ON" : "OFF"));
        }

        // Add a moon to the most massive particle
        function addMoon() {
            if (particles.length === 0) {
                console.warn("Cannot add a moon: no particles exist to orbit around.");
                return;
            }

            // Find the most massive particle to orbit around
            let parentParticle = particles[0];
            for (let i = 1; i < particles.length; i++) {
                if (particles[i].mass > parentParticle.mass) {
                    parentParticle = particles[i];
                }
            }

            // Random Moon Mass in proportion to the parent particle's mass
            const moonMass = parentParticle.mass * (0.005 + Math.random() * 0.05); // 0.5% to 5.5% of parent's mass
            // Random Orbit Distance
            const orbitDistance = 5 + Math.random() * 20; // Closer range for moons

            // Generate a random initial position around the parent
            let randomDirection = new BABYLON.Vector3(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize();

            let moonPosition = parentParticle.position.add(randomDirection.scale(orbitDistance));

            // Calculate tangential velocity for a circular orbit
            let requiredSpeed = Math.sqrt(G_EFFECTIVE * parentParticle.mass / orbitDistance);

            // Direction vector from parent to moon
            let directionToMoon = moonPosition.subtract(parentParticle.position).normalize();

            // Generate a more random normal vector for the orbital plane (more exotic orbits)
            let orbitNormal = new BABYLON.Vector3(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize();

            // Ensure orbitNormal is not too close to directionToMoon for cross product stability
            if (BABYLON.Vector3.Dot(directionToMoon, orbitNormal) > 0.95 || BABYLON.Vector3.Dot(directionToMoon, orbitNormal) < -0.95) {
                // If nearly parallel, pick a perpendicular vector
                if (Math.abs(directionToMoon.y) < 0.8) {
                    orbitNormal = new BABYLON.Vector3(0, 1, 0).normalize();
                } else {
                    orbitNormal = new BABYLON.Vector3(1, 0, 0).normalize();
                }
            }

            let tangentialDirection = BABYLON.Vector3.Cross(directionToMoon, orbitNormal).normalize();

            let orbitalDirectionMultiplier = Math.random() < 0.5 ? 1 : -1;
            tangentialDirection.scaleInPlace(orbitalDirectionMultiplier);

            // Adjust for existing parent velocity to ensure relative orbit
            let moonVelocity = parentParticle.velocity.add(tangentialDirection.scale(requiredSpeed));

            let moonName = `Moon-${particleIdCounter++}`;
            let sphere = BABYLON.MeshBuilder.CreateSphere(moonName, {diameter: 1 * 0.5 * 0.5}, scene);
            sphere.position = moonPosition;

            let moonMaterial = new BABYLON.StandardMaterial("moonMat" + particles.length, scene);
            moonMaterial.emissiveColor = getRandomColor(); // Moons can have random colors
            sphere.material = moonMaterial;

            let moonParticle = {
                name: moonName,
                mesh: sphere,
                position: moonPosition.clone(),
                velocity: moonVelocity,
                mass: moonMass,
                initialDiameter: 1 * 0.5 * 0.5, // Store reduced diameter
                orbitPoints: [moonPosition.clone()],
                orbitMesh: null,
                type: currentParticleType,
                nameText: null,
                massText: null
            };

            particles.push(moonParticle);
            console.log(`Added a ${moonParticle.name} (${moonParticle.type}) with mass ${moonMass.toFixed(0)} orbiting ${parentParticle.name}.`);
            updateParticleCountDisplay();
        }

        // Update the particle count display
        function updateParticleCountDisplay() {
            document.getElementById("particleCount").innerText = "Particles: " + particles.length;
        }
    </script>
</body>
</html>
