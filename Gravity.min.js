// Global variables for the simulation
var h=.005,context,particleList=[],frametime,starttime,width,height,startCoords=[-1,-1],endCoords=[-1,-1],newMass=1e3,onControlBox=!1,shiftDown=!1,trailsEnabled=!1,currentParticleType="matter",gravityFieldEnabled=!1,showParticleNames=!1;

// NEW: Zoom and Pan variables
var zoomLevel = 1.0; // Nivel de zoom actual
var panX = 0;        // Desplazamiento horizontal del lienzo
var panY = 0;        // Desplazamiento vertical del lienzo

// NEW: Magnetosphere variables
var showMagnetospheres = false; // New global variable to control magnetosphere visibility
var magnetosphereList = []; // New global variable to hold Magnetosphere objects

// NEW: Orbit variables
var showOrbits = false; // Variable global para controlar la visibilidad de las órbitas

// NEW: Gravity Well variable
var showGravityWells = false; // Variable global para controlar la visibilidad del pozo gravitatorio

// Initializes the canvas and event listeners
function init(){
    var t=document.getElementById("canvas"),e=document.getElementById("controlbox");
    // Quintuplicar el tamaño del canvas
    t.width = (window.innerWidth - 30) * 1; // Multiplicar el ancho por 5
    t.height = (window.innerHeight - 20) * 1; // Multiplicar la altura por 5
    width=t.width;
    height=t.height;
    context=t.getContext("2d");

    window.addEventListener("mousedown",mouseDownListener,!1);
    // NEW: Listener para la rueda del ratón para el zoom
    window.addEventListener('wheel', mouseWheelListener, { passive: false });
    e.onmouseover=function(){onControlBox=!0};
    e.onmouseout=function(){onControlBox=!1};
}

// Main simulation loop
function main(){starttime=Date.now(),integrate(),draw(),frametime=Date.now()-starttime}

// Mouse down event listener
function mouseDownListener(t){
    onControlBox||(
        shiftDown=t.shiftKey,
        startCoords[0]=t.clientX,
        startCoords[1]=t.clientY,
        endCoords[0]=t.clientX,
        endCoords[1]=t.clientY,
        window.addEventListener("mousemove",mouseMoveListener,!1),
        window.addEventListener("mouseup",mouseUpListener,!1)
    )
}

// Mouse move event listener
function mouseMoveListener(t){endCoords[0]=t.clientX,endCoords[1]=t.clientY}

// Mouse up event listener
function mouseUpListener(t){
    window.removeEventListener("mousemove",mouseMoveListener);
    window.removeEventListener("mouseup",mouseUpListener);

    if (!t.shiftKey && !shiftDown) { // Añadir nueva partícula
        // Convertir coordenadas de pantalla a coordenadas del mundo para la nueva partícula
        var worldStartX = (startCoords[0] - panX) / zoomLevel;
        var worldStartY = (startCoords[1] - panY) / zoomLevel;
        var worldEndX = (endCoords[0] - panX) / zoomLevel;
        var worldEndY = (endCoords[1] - panY) / zoomLevel;

        particleList.push(new Particle(newMass, worldStartX, worldStartY, (worldEndX - worldStartX), (worldEndY - worldStartY), currentParticleType, ""));
    } else if (t.shiftKey && shiftDown) { // Paneo de la vista
        // Calcular el delta de la pantalla
        var screenDx = endCoords[0] - startCoords[0];
        var screenDy = endCoords[1] - startCoords[1];

        // Aplicar el delta de la pantalla directamente a los offsets de paneo
        panX += screenDx;
        panY += screenDy;
    }
    startCoords=[-1,-1];
    endCoords=[-1,-1];
}

// NEW: Mouse wheel listener for zoom
function mouseWheelListener(event) {
    event.preventDefault(); // Prevenir el desplazamiento de la página

    var scaleFactor = 1.1; // Factor de zoom
    var mouseX = event.clientX;
    var mouseY = event.clientY;

    // Determinar la dirección del zoom
    var delta = event.deltaY > 0 ? 1 / scaleFactor : scaleFactor;

    // Calcular coordenadas del mundo antes del zoom
    var worldX = (mouseX - panX) / zoomLevel;
    var worldY = (mouseY - panY) / zoomLevel;

    // Aplicar zoom
    zoomLevel *= delta;

    // Ajustar el paneo para mantener el punto del mundo bajo el ratón fijo
    panX = mouseX - worldX * zoomLevel;
    panY = mouseY - worldY * zoomLevel;

    // Solicitar redibujar
    main(); // Llamar a main para actualizar la vista inmediatamente
}


// Sets the mass for new particles
function setNewMass(t){newMass=t}

// Toggles particle trails
function toggleTrails(){trailsEnabled=!trailsEnabled}

// Toggles particle type (matter/antimatter)
function toggleParticleType(){currentParticleType=currentParticleType=="matter"?"antimatter":"matter",document.getElementById("particleTypeBtn").innerHTML=currentParticleType=="matter"?"Matter":"Antimatter"}

// Toggles gravitational field visualization
function toggleGravityField(){gravityFieldEnabled=!gravityFieldEnabled}

// Toggles particle name display
function toggleParticleNames(){showParticleNames=!showParticleNames}

// Toggles magnetosphere visibility
function toggleMagnetospheres() {
    showMagnetospheres = !showMagnetospheres; // Toggle the state
}

// Toggles orbit visibility
function toggleOrbits() {
    showOrbits = !showOrbits; // Toggle the state
    // Si las órbitas se ocultan, limpiar los historiales de las partículas para que no se dibujen puntos antiguos al volver a mostrar
    if (!showOrbits) {
        for (var i = 0; i < particleList.length; i++) {
            particleList[i].path = [];
        }
    }
}

// NEW: Toggles gravity well visibility
function toggleGravityWells() {
    showGravityWells = !showGravityWells; // Toggle the state
}


// Integrates particle physics (calculates forces and updates positions/velocities)
function integrate(){
    // Calculate accelerations
    for(var t=0;t<particleList.length;t++){
        var e=particleList[t];e.ax=0,e.ay=0;
        for(var o=0;o<particleList.length;o++){
            if(t!==o){
                var r=particleList[o],i=r.x-e.x,s=r.y-e.y,a=Math.sqrt(i*i+s*s);
                if(a>1e-5){
                    var n=e.type==r.type?1:-1;
                    e.ax+=n*r.mass*i/(a*a*a),e.ay+=n*r.mass*s/(a*a*a)
                }
            }
        }
    }

    // Update velocities and positions (no particleShift here anymore)
    for(var c=[],l=0;l<particleList.length;l++){
        var d=particleList[l];
        d.vx+=d.ax*h;
        d.vy+=d.ay*h;
        d.x+=d.vx*h;
        d.y+=d.vy*h;

        // Almacenar la posición actual en el historial de la órbita
        if (showOrbits) {
            d.path.push({x: d.x, y: d.y});
            if (d.path.length > d.pathLength) {
                d.path.shift(); // Eliminar el punto más antiguo
            }
        }
    }

    // Clear and regenerate magnetospheres each frame based on existing particles
    magnetosphereList = []; // Clear existing magnetospheres
    for (var i = 0; i < particleList.length; i++) {
        var p = particleList[i];
        // Example: Create a magnetosphere for every "matter" particle with a certain mass
        if (p.type === "matter" && p.mass > 10000) { // Adjust mass threshold as needed
            magnetosphereList.push(new Magnetosphere(p, p.mass / 100, "rgba(0, 100, 255, 0.2)")); // Example strength and color
        }
    }


    // Handle collisions (merging particles)
    for(var p=new Array(particleList.length).fill(!1),u=0;u<particleList.length;u++){
        if(!p[u]){
            var m=particleList[u];
            for(var f=u+1;f<particleList.length;f++){
                if(!p[f]){
                    var g=particleList[f],v=g.x-m.x,y=g.y-m.y,b=Math.sqrt(v*v+y*y);
                    if(b<m.radius/1.5+g.radius/1.5){
                        p[u]=!0,p[f]=!0;
                        var w=m.mass+g.mass,x=(m.x*m.mass+g.x*g.mass)/w,P=(m.y*m.mass+g.y*g.mass)/w,C=(m.vx*m.mass+g.vx*g.mass)/w,A=(m.vy*m.mass+g.vy*g.mass)/w;
                        c.push(new Particle(w,x,P,C,A,m.type==g.type?m.type:"matter","")); // Pass empty name for merged
                        break
                    }
                }
            }
        }
    }

    // Filter out collided particles and add new ones
    for(var S=[],k=0;k<particleList.length;k++)!p[k]&&particleList[k].x>=-50&&particleList[k].y>=-50&&particleList[k].x<=width+50&&particleList[k].y<=height+50&&S.push(particleList[k]);
    particleList=S.concat(c);
}

// Draws all elements on the canvas
function draw(){
    // Clear the canvas or draw trails depending on trailsEnabled
    trailsEnabled?(context.fillStyle="rgba(0,0,0,0.05)",context.fillRect(0,0,width,height)):context.clearRect(0,0,width,height);

    // Save the current canvas state before applying transformations
    context.save();

    // Apply pan and zoom transformations
    context.translate(panX, panY);
    context.scale(zoomLevel, zoomLevel);

    // Draw the drag line for creating new particles (if active)
    // Convert screen coordinates to world coordinates relative to the current view for drawing the line.
    var worldDragStartX = (startCoords[0] - panX) / zoomLevel;
    var worldDragStartY = (startCoords[1] - panY) / zoomLevel;
    var worldDragEndX = (endCoords[0] - panX) / zoomLevel;
    var worldDragEndY = (endCoords[1] - panY) / zoomLevel;

    context.beginPath();
    context.moveTo(worldDragStartX, worldDragStartY);
    context.lineTo(worldDragEndX, worldDragEndY);
    context.strokeStyle="blue";
    context.lineWidth=2 / zoomLevel; // Escalar el ancho de línea con el zoom
    context.stroke();


    // Logic to draw the gravitational field (if enabled)
    if(gravityFieldEnabled){
        var gridSize=40; // Tamaño de la cuadrícula (distancia entre puntos de muestreo)
        var arrowLength=15; // Longitud de las flechas del campo
        var maxFieldStrength=0; // Para normalizar la intensidad del color

        // Calcular los límites del mundo visible para dibujar el campo
        var worldViewLeft = (0 - panX) / zoomLevel;
        var worldViewTop = (0 - panY) / zoomLevel;
        var worldViewRight = (width - panX) / zoomLevel;
        var worldViewBottom = (height - panY) / zoomLevel;

        // Primera pasada: Calcula la fuerza máxima para normalizar la visualización
        for(var y = worldViewTop; y < worldViewBottom; y += gridSize){
            for(var x = worldViewLeft; x < worldViewRight; x += gridSize){
                var totalAx = 0;
                var totalAy = 0;

                for(var i=0;i<particleList.length;i++){
                    var particle=particleList[i];
                    var dx=particle.x-x;
                    var dy=particle.y-y;
                    var distanceSq=dx*dx+dy*dy;

                    if(distanceSq<100){continue}

                    var distance=Math.sqrt(distanceSq);
                    var forceMagnitude=particle.mass/distanceSq;
                    var sign=particle.type==="matter"?1:-1;

                    totalAx+=sign*forceMagnitude*dx/distance;
                    totalAy+=sign*forceMagnitude*dy/distance;
                }
                var fieldStrength=Math.sqrt(totalAx*totalAx+totalAy*totalAy);
                if(fieldStrength>maxFieldStrength){maxFieldStrength=fieldStrength}
            }
        }

        // Segunda pasada: Dibuja las líneas/flechas del campo
        for(var y = worldViewTop; y < worldViewBottom; y += gridSize){
            for(var x = worldViewLeft; x < worldViewRight; x += gridSize){
                var totalAx=0;
                var totalAy=0;

                for(var i=0;i<particleList.length;i++){
                    var particle=particleList[i];
                    var dx=particle.x-x;
                    var dy=particle.y-y;
                    var distanceSq=dx*dx+dy*dy;

                    if(distanceSq<100){continue}

                    var distance=Math.sqrt(distanceSq);
                    var forceMagnitude=particle.mass/distanceSq;
                    var sign=particle.type==="matter"?1:-1;

                    totalAx+=sign*forceMagnitude*dx/distance;
                    totalAy+=sign*forceMagnitude*dy/distance;
                }

                var fieldStrength=Math.sqrt(totalAx*totalAx+totalAy*totalAy);

                if(fieldStrength>0){
                    var normalizedStrength=maxFieldStrength>0?fieldStrength/maxFieldStrength:0;
                    var colorValue=Math.floor(normalizedStrength*255);

                    if(particleList.length>0&&particleList[0].type==="matter"){
                        context.strokeStyle="rgb("+(255-colorValue)+", "+(255-colorValue/2)+", 255)";
                    }else{
                        context.strokeStyle="rgb(255, "+(255-colorValue)+", "+(255-colorValue)+")";
                    }

                    context.lineWidth=1 / zoomLevel; // Escalar el ancho de línea con el zoom

                    var angle=Math.atan2(totalAy,totalAx);
                    var startWorldX = x;
                    var startWorldY = y;
                    var endWorldX = x + arrowLength * normalizedStrength * Math.cos(angle);
                    var endWorldY = y + arrowLength * normalizedStrength * Math.sin(angle);

                    context.beginPath();
                    context.moveTo(startWorldX,startWorldY);
                    context.lineTo(endWorldX,endWorldY);
                    context.stroke();

                    context.save();
                    context.translate(endWorldX,endWorldY);
                    context.rotate(angle);
                    context.beginPath();
                    context.moveTo(0,0);
                    context.lineTo(-5 / zoomLevel,-3 / zoomLevel); // Escalar el tamaño de la punta de flecha
                    context.lineTo(-5 / zoomLevel,3 / zoomLevel);  // Escalar el tamaño de la punta de flecha
                    context.closePath();
                    context.fillStyle=context.strokeStyle;
                    context.fill();
                    context.restore();
                }
            }
        }
    }

    // Draw all magnetospheres (if enabled)
    if (showMagnetospheres) {
        for (var i = 0; i < magnetosphereList.length; i++) {
            magnetosphereList[i].draw(context, zoomLevel);
        }
    }

    // Draw all particle orbits (if enabled)
    if (showOrbits) {
        context.lineWidth = 1 / zoomLevel; // Las líneas de órbita siempre tienen 1 pixel de ancho
        for (var i = 0; i < particleList.length; i++) {
            var p = particleList[i];
            if (p.path.length > 1) {
                context.beginPath();
                context.strokeStyle = "rgba(" + p.color[0] + "," + p.color[1] + "," + p.color[2] + ", 0.5)"; // Color de la órbita (semi-transparente)
                context.moveTo(p.path[0].x, p.path[0].y);
                for (var j = 1; j < p.path.length; j++) {
                    context.lineTo(p.path[j].x, p.path[j].y);
                }
                context.stroke();
            }
        }
    }

    // NEW: Draw gravity wells (if enabled)
    if (showGravityWells) {
        for (var i = 0; i < particleList.length; i++) {
            var p = particleList[i];
            if (p.type === "matter" && p.mass > 0) { // Solo para partículas de 'matter' con masa
                var maxRadius = p.radius * 10 + Math.log(p.mass) * 5; // Radio máximo del pozo (ajustable)
                var numCircles = 20; // Número de círculos concéntricos
                var colorBase = p.color;

                for (var j = 1; j <= numCircles; j++) {
                    var currentRadius = maxRadius * (j / numCircles);
                    var alpha = 0.3 * (1 - (j / numCircles)); // Disminuir opacidad hacia afuera

                    context.beginPath();
                    context.arc(p.x, p.y, currentRadius, 0, 2 * Math.PI);
                    context.strokeStyle = "rgba(" + colorBase[0] + "," + colorBase[1] + "," + colorBase[2] + "," + alpha + ")";
                    context.lineWidth = 1 / zoomLevel; // Mantener un pixel de ancho
                    context.stroke();
                }
            }
        }
    }


    // Draw all particles
    for(var t=0;t<particleList.length;t++){
        var e=particleList[t],o=context.createRadialGradient(e.x,e.y,.75*e.radius,e.x,e.y,e.radius);
        o.addColorStop(0,"rgba("+e.color[0]+","+e.color[1]+","+e.color[2]+",1.0)");
        o.addColorStop(1,"rgba("+e.color[0]+","+e.color[1]+","+e.color[2]+",0)");

        context.beginPath();
        context.arc(e.x,e.y,e.radius,0,2*Math.PI);
        context.closePath();
        context.fillStyle=e.radius<3?"#"+e.color[3]:o;
        context.fill();

        // Draw particle name if enabled and name exists
        if(showParticleNames&&e.name){
            context.fillStyle="#ffffff"; // Color del texto
            context.font=(10 / zoomLevel) + "px Arial"; // Escalar el tamaño de la fuente
            context.textAlign="center"; // Alineación del texto
            context.fillText(e.name,e.x,e.y-e.radius-5 / zoomLevel); // Escalar el offset del texto
        }
    }

    // Restore the canvas state
    context.restore();
}
