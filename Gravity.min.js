// Global variables
var h = 0.005;
var context, particleList = [], wormholeList = [];
var frametime, starttime, width, height;
var startCoords = [-1, -1], endCoords = [-1, -1];
var newMass = 1e3, onControlBox = false, shiftDown = false;
var trailsEnabled = false, currentParticleType = "matter";
var gravityFieldEnabled = false, showParticleNames = false;
var showMagnetospheres = false, magnetosphereList = [];
var showOrbits = false, showGravityWells = false;
var showParticleMass = false, showGravitationalLensing = false;
var collisionEffectsEnabled = true;

// Camera variables
var zoomLevel = 1.0;
var panX = 0;
var panY = 0;

// Physics parameters
var G = 1; // Gravitational constant
var collisionRestitution = 0.8; // Energy retained after collision
var darkMatterInteractionFactor = 0.5; // How much dark matter interacts with other dark matter

// Initializes the canvas and event listeners
function init() {
    var canvas = document.getElementById("canvas");
    var controlBox = document.getElementById("controlbox");
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    width = canvas.width;
    height = canvas.height;
    context = canvas.getContext("2d");
    
    // Event listeners
    window.addEventListener("mousedown", mouseDownListener, false);
    window.addEventListener('wheel', mouseWheelListener, { passive: false });
    controlBox.onmouseover = function() { onControlBox = true; };
    controlBox.onmouseout = function() { onControlBox = false; };
}

// Mouse down event listener
function mouseDownListener(t){
    onControlBox||(
        shiftDown=t.shiftKey,
        startCoords[0]=t.clientX,
        startCoords[1]=t.clientY,
        endCoords[0]=t.clientX,
        endCoords[1]=t.clientY,
        window.addEventListener("mousemove",mouseMoveListener,!1),
        window.addEventListener("mouseup",mouseUpListener,!1)
    )
}

// Mouse move event listener
function mouseMoveListener(t){endCoords[0]=t.clientX,endCoords[1]=t.clientY}

// Mouse up event listener
function mouseUpListener(t){
    window.removeEventListener("mousemove",mouseMoveListener);
    window.removeEventListener("mouseup",mouseUpListener);

    if (!t.shiftKey && !shiftDown) {
        var worldStartX = (startCoords[0] - panX) / zoomLevel;
        var worldStartY = (startCoords[1] - panY) / zoomLevel;
        var worldEndX = (endCoords[0] - panX) / zoomLevel;
        var worldEndY = (endCoords[1] - panY) / zoomLevel;

        particleList.push(new Particle(newMass, worldStartX, worldStartY, (worldEndX - worldStartX), (worldEndY - worldStartY), currentParticleType, "New Particle"));
    } else if (t.shiftKey && shiftDown) {
        var screenDx = endCoords[0] - startCoords[0];
        var screenDy = endCoords[1] - startCoords[1];

        panX += screenDx;
        panY += screenDy;
    }
    startCoords=[-1,-1];
    endCoords=[-1,-1];
}

// Mouse wheel listener for zoom
function mouseWheelListener(event) {
    event.preventDefault();

    var scaleFactor = 1.1;
    var mouseX = event.clientX;
    var mouseY = event.clientY;

    var delta = event.deltaY > 0 ? 1 / scaleFactor : scaleFactor;

    var worldX = (mouseX - panX) / zoomLevel;
    var worldY = (mouseY - panY) / zoomLevel;

    zoomLevel *= delta;

    panX = mouseX - worldX * zoomLevel;
    panY = mouseY - worldY * zoomLevel;

    main();
}

// Sets the mass for new particles
function setNewMass(t){newMass=t}

// Sets the mass for new particles
function setNewMass(t){newMass=t}

// Toggles particle trails
function toggleTrails(){trailsEnabled=!trailsEnabled}

// Toggles particle type (matter/antimatter)
function toggleParticleType(){currentParticleType=currentParticleType=="matter"?"antimatter":"matter",document.getElementById("particleTypeBtn").innerHTML=currentParticleType=="matter"?"Matter":"Antimatter"}

// Toggles gravitational field visualization
var gravityFieldMode = 0;
function toggleGravityField(){
    gravityFieldMode = (gravityFieldMode + 1) % 3;
    gravityFieldEnabled = gravityFieldMode > 0;
    document.getElementById("gravityFieldBtn").innerHTML = 
        gravityFieldMode === 0 ? "Show Field" : 
        gravityFieldMode === 1 ? "Show Arrows Field" : "Show Grid Field";
}

// Toggles particle name display
function toggleParticleNames(){showParticleNames=!showParticleNames}

// Toggles magnetosphere visibility
function toggleMagnetospheres() {
    showMagnetospheres = !showMagnetospheres;
}

// Toggles orbit visibility
function toggleOrbits() {
    showOrbits = !showOrbits;
}

// Function to clear all particle orbit paths
function clearAllParticleOrbits() {
    for (var i = 0; i < particleList.length; i++) {
        particleList[i].path = [];
    }
}

// Toggles gravity well visibility
function toggleGravityWells() {
    showGravityWells = !showGravityWells;
}

// Toggles particle mass display
function toggleParticleMass() {
    showParticleMass = !showParticleMass;
}

// Main simulation loop
function main() {
    starttime = Date.now();
    if (!isPaused) {
        integrate();
    }
    draw();
    frametime = Date.now() - starttime;
}

// Integrates particle physics
function integrate(){
    // Calculate accelerations
    for(var t=0;t<particleList.length;t++){
        var e=particleList[t];e.ax=0,e.ay=0;
        for(var o=0;o<particleList.length;o++){
            if(t!==o){
                var r=particleList[o],i=r.x-e.x,s=r.y-e.y,a=Math.sqrt(i*i+s*s);
                if(a>1e-5){
                    var n=e.type==r.type?1:-1;
                    // Increased gravity for black holes
                    var forceMultiplier = r.isBlackHole ? 10 : 1;
                    e.ax+=n*r.mass*i/(a*a*a)*forceMultiplier;
                    e.ay+=n*r.mass*s/(a*a*a)*forceMultiplier;
                    
                    // Absorb particles that cross event horizon
                    if (r.isBlackHole && a < r.eventHorizonRadius) {
                        e.x = r.x;
                        e.y = r.y;
                        e.vx = r.vx;
                        e.vy = r.vy;
                    }
                }
            }
        }
    }

    // Update velocities and positions
    for(var c=[],l=0;l<particleList.length;l++){
        var d=particleList[l];
        d.vx+=d.ax*h;
        d.vy+=d.ay*h;
        d.x+=d.vx*h;
        d.y+=d.vy*h;

        if (showOrbits) {
            d.path.push({x: d.x, y: d.y});
            if (d.path.length > d.pathLength) {
                d.path.shift();
            }
        }
    }

    // Clear and regenerate magnetospheres
    magnetosphereList = [];
    for (var i = 0; i < particleList.length; i++) {
        var p = particleList[i];
        if (p.type === "matter" && p.mass > 10000) {
            magnetosphereList.push(new Magnetosphere(p, p.mass / 100, "rgba(0, 100, 255, 0.2)"));
        }
    }

    // Handle collisions (merging particles)
    for(var p=new Array(particleList.length).fill(!1),u=0;u<particleList.length;u++){
        if(!p[u]){
            var m=particleList[u];
            for(var f=u+1;f<particleList.length;f++){
                if(!p[f]){
                    var g=particleList[f],v=g.x-m.x,y=g.y-m.y,b=Math.sqrt(v*v+y*y);
                    if(b<m.radius/1.5+g.radius/1.5){
                        p[u]=!0,p[f]=!0;
                        var w=m.mass+g.mass,x=(m.x*m.mass+g.x*g.mass)/w,P=(m.y*m.mass+g.y*g.mass)/w,C=(m.vx*m.mass+g.vx*g.mass)/w,A=(m.vy*m.mass+g.vy*g.mass)/w;
                        // When merging with black hole, result is always black hole
                        var mergedType = (m.isBlackHole || g.isBlackHole) ? "blackhole" : (m.type==g.type?m.type:"matter");
                        c.push(new Particle(w,x,P,C,A,mergedType,"Merged Particle"));
                        break
                    }
                }
            }
        }
    }

    // Filter out collided particles and add new ones
    for(var S=[],k=0;k<particleList.length;k++)!p[k]&&particleList[k].x>=-50&&particleList[k].y>=-50&&particleList[k].x<=width+50&&particleList[k].y<=height+50&&S.push(particleList[k]);
    particleList=S.concat(c);
}

// Drawing function
function draw() {
    // Clear canvas
    if (trailsEnabled) {
        context.fillStyle = "rgba(0, 0, 0, 0.05)";
        context.fillRect(0, 0, width, height);
    } else {
        context.clearRect(0, 0, width, height);
    }
    
    context.save();
    context.translate(panX, panY);
    context.scale(zoomLevel, zoomLevel);
    
    // Draw gravity field if enabled
    if (gravityFieldEnabled) {
        drawGravityField();
    }
    
    // Draw magnetospheres (if enabled)
    if (showMagnetospheres) {
        for (var i = 0; i < magnetosphereList.length; i++) {
            magnetosphereList[i].draw(context, zoomLevel);
        }
    }
    
    // Draw orbits (if enabled)
    if (showOrbits) {
        drawOrbits();
    }
    
    // Draw gravity wells (if enabled)
    if (showGravityWells) {
        drawGravityWells();
    }
    
    // Draw gravitational lensing (if enabled)
    if (showGravitationalLensing) {
        drawGravitationalLensing();
    }
    
    // Draw all particles
    for (var i = 0; i < particleList.length; i++) {
        var p = particleList[i];
        
        // Skip drawing if it's a black hole (we'll draw it later with special effects)
        if (p.isBlackHole) continue;
        
        // Draw particle
        drawParticle(p);
        
        // Draw particle name/mass if enabled
        if (showParticleNames && p.name) {
            context.fillStyle = "#ffffff";
            context.font = (10 / zoomLevel) + "px Arial";
            context.textAlign = "center";
            context.fillText(p.name, p.x, p.y - p.radius - 5 / zoomLevel);
        }
        
        if (showParticleMass) {
            context.fillStyle = "#ffffff";
            context.font = (8 / zoomLevel) + "px Arial";
            context.textAlign = "center";
            var massText = p.mass < 10000 ? p.mass.toFixed(0) : p.mass.toExponential(1);
            context.fillText("Mass: " + massText, p.x, p.y + p.radius + (showParticleNames ? 15 / zoomLevel : 5 / zoomLevel));
        }
    }
    
    // Draw black holes with special effects
    for (var i = 0; i < particleList.length; i++) {
        var p = particleList[i];
        if (p.isBlackHole) {
            drawBlackHole(p);
        }
    }
    
    // Draw wormholes
    for (var i = 0; i < wormholeList.length; i++) {
        var wormhole = wormholeList[i];
        if (particleList.includes(wormhole)) {
            drawWormhole(wormhole);
        }
    }
    
    // Draw the drag line for creating new particles
    if (startCoords[0] !== -1 && endCoords[0] !== -1) {
        var worldDragStartX = (startCoords[0] - panX) / zoomLevel;
        var worldDragStartY = (startCoords[1] - panY) / zoomLevel;
        var worldDragEndX = (endCoords[0] - panX) / zoomLevel;
        var worldDragEndY = (endCoords[1] - panY) / zoomLevel;
        
        context.beginPath();
        context.moveTo(worldDragStartX, worldDragStartY);
        context.lineTo(worldDragEndX, worldDragEndY);
        context.strokeStyle = "blue";
        context.lineWidth = 2 / zoomLevel;
        context.stroke();
    }
    
    context.restore();
    
    // Update particle count
    document.getElementById("particleCount").innerText = "Particles: " + particleList.length;
}

// Helper drawing functions
function drawParticle(p) {
    // Collision effect - glow
    if (p.collisionTimer > 0) {
        var glow = context.createRadialGradient(
            p.x, p.y, p.radius,
            p.x, p.y, p.radius * (1 + p.collisionEnergy * 2)
        );
        glow.addColorStop(0, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 1)`);
        glow.addColorStop(1, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 0)`);
        
        context.beginPath();
        context.arc(p.x, p.y, p.radius * (1 + p.collisionEnergy * 2), 0, 2 * Math.PI);
        context.fillStyle = glow;
        context.fill();
    }
    
    // Particle itself
    var gradient = context.createRadialGradient(
        p.x, p.y, p.radius * 0.75,
        p.x, p.y, p.radius
    );
    gradient.addColorStop(0, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 1)`);
    gradient.addColorStop(1, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 0)`);
    
    context.beginPath();
    context.arc(p.x, p.y, p.radius, 0, 2 * Math.PI);
    context.fillStyle = p.radius < 3 ? "#" + p.color[3] : gradient;
    context.fill();
    
    // Neutron star pulsar beams
    if (p.type === "neutron") {
        p.pulsePhase = (p.pulsePhase + h * 5) % (2 * Math.PI);
        var pulseIntensity = 0.5 + 0.5 * Math.sin(p.pulsePhase);
        
        for (var i = 0; i < 2; i++) {
            var angle = p.pulsePhase + i * Math.PI;
            context.beginPath();
            context.moveTo(p.x, p.y);
            context.lineTo(
                p.x + Math.cos(angle) * p.magnetosphereRadius * 2,
                p.y + Math.sin(angle) * p.magnetosphereRadius * 2
            );
            context.strokeStyle = `rgba(0, 200, 255, ${pulseIntensity * 0.7})`;
            context.lineWidth = 3 / zoomLevel;
            context.stroke();
        }
    }
}

function drawBlackHole(p) {
    // Accretion disk
    var gradient = context.createRadialGradient(
        p.x, p.y, p.eventHorizonRadius,
        p.x, p.y, p.accretionDiskRadius
    );
    gradient.addColorStop(0, "rgba(255, 100, 0, 0.8)");
    gradient.addColorStop(1, "rgba(255, 255, 0, 0.2)");
    
    context.beginPath();
    context.arc(p.x, p.y, p.accretionDiskRadius, 0, 2 * Math.PI);
    context.fillStyle = gradient;
    context.fill();
    
    // Event horizon
    context.beginPath();
    context.arc(p.x, p.y, p.eventHorizonRadius, 0, 2 * Math.PI);
    context.fillStyle = "rgba(0, 0, 0, 0.9)";
    context.fill();
    context.strokeStyle = "rgba(255, 255, 255, 0.5)";
    context.lineWidth = 2 / zoomLevel;
    context.stroke();
    
    // Jets
    context.beginPath();
    context.moveTo(p.x, p.y - p.eventHorizonRadius * 4);
    context.lineTo(p.x, p.y - p.eventHorizonRadius * 10);
    context.strokeStyle = "rgba(255, 100, 0, 0.7)";
    context.lineWidth = 3 / zoomLevel;
    context.stroke();
    
    context.beginPath();
    context.moveTo(p.x, p.y + p.eventHorizonRadius * 4);
    context.lineTo(p.x, p.y + p.eventHorizonRadius * 10);
    context.stroke();
    
    // Name and mass
    if (showParticleNames && p.name) {
        context.fillStyle = "#ffffff";
        context.font = (10 / zoomLevel) + "px Arial";
        context.textAlign = "center";
        context.fillText(p.name, p.x, p.y - p.accretionDiskRadius - 10 / zoomLevel);
    }
    
    if (showParticleMass) {
        context.fillStyle = "#ffffff";
        context.font = (8 / zoomLevel) + "px Arial";
        context.textAlign = "center";
        var massText = p.mass.toExponential(1);
        context.fillText("Mass: " + massText, p.x, p.y + p.accretionDiskRadius + 10 / zoomLevel);
    }
}

function drawWormhole(w) {
    // Wormhole entrance
    var gradient = context.createRadialGradient(
        w.x, w.y, w.radius,
        w.x, w.y, w.wormholeRadius
    );
    gradient.addColorStop(0, "rgba(150, 0, 255, 0.9)");
    gradient.addColorStop(1, "rgba(50, 0, 150, 0.2)");
    
    context.beginPath();
    context.arc(w.x, w.y, w.wormholeRadius, 0, 2 * Math.PI);
    context.fillStyle = gradient;
    context.fill();
    
    // Connection line if linked
    if (w.linkedWormhole && particleList.includes(w.linkedWormhole)) {
        context.beginPath();
        context.moveTo(w.x, w.y);
        context.lineTo(w.linkedWormhole.x, w.linkedWormhole.y);
        context.strokeStyle = "rgba(150, 0, 255, 0.3)";
        context.lineWidth = 1 / zoomLevel;
        context.stroke();
    }
    
    // Name
    if (showParticleNames && w.name) {
        context.fillStyle = "#ffffff";
        context.font = (10 / zoomLevel) + "px Arial";
        context.textAlign = "center";
        context.fillText(w.name, w.x, w.y - w.wormholeRadius - 10 / zoomLevel);
    }
}

function drawGravityField() {
        var gridSize = 10;
        var lineWidth = 1 / zoomLevel;
        
        var worldViewLeft = Math.max(0, (0 - panX) / zoomLevel);
        var worldViewTop = Math.max(0, (0 - panY) / zoomLevel);
        var worldViewRight = Math.min(width, (width - panX) / zoomLevel);
        var worldViewBottom = Math.min(height, (height - panY) / zoomLevel);

        context.beginPath();
        context.strokeStyle = "rgba(100, 100, 255, 0.5)";
        context.lineWidth = lineWidth;
        
        for(var y = worldViewTop; y < worldViewBottom; y += gridSize){
            var points = [];
            for(var x = worldViewLeft; x <= worldViewRight; x += 5){
                var displacedX = x;
                var displacedY = y;
                
                for(var i = 0; i < particleList.length; i++){
                    var p = particleList[i];
                    var dx = p.x - x;
                    var dy = p.y - y;
                    var distSq = dx*dx + dy*dy;
                    
                    if(distSq < 10000 && distSq > 100){
                        var dist = Math.sqrt(distSq);
                        var force = p.mass / distSq * (p.type === "matter" ? 1 : -1);
                        var displacement = Math.min(20, force * 1000 / dist);
                        
                        displacedX += dx * displacement / dist;
                        displacedY += dy * displacement / dist;
                    }
                }
                
                points.push({x: displacedX, y: displacedY});
            }
            
            if(points.length > 1){
                context.moveTo(points[0].x, points[0].y);
                for(var j = 1; j < points.length; j++){
                    context.lineTo(points[j].x, points[j].y);
                }
            }
        }
        context.stroke();
        
        context.beginPath();
        context.strokeStyle = "rgba(100, 100, 255, 0.5)";
        context.lineWidth = lineWidth;
        
        for(var x = worldViewLeft; x < worldViewRight; x += gridSize){
            var points = [];
            for(var y = worldViewTop; y <= worldViewBottom; y += 5){
                var displacedX = x;
                var displacedY = y;
                
                for(var i = 0; i < particleList.length; i++){
                    var p = particleList[i];
                    var dx = p.x - x;
                    var dy = p.y - y;
                    var distSq = dx*dx + dy*dy;
                    
                    if(distSq < 10000 && distSq > 100){
                        var dist = Math.sqrt(distSq);
                        var force = p.mass / distSq * (p.type === "matter" ? 1 : -1);
                        var displacement = Math.min(20, force * 1000 / dist);
                        
                        displacedX += dx * displacement / dist;
                        displacedY += dy * displacement / dist;
                    }
                }
                
                points.push({x: displacedX, y: displacedY});
            }
            
            if(points.length > 1){
                context.moveTo(points[0].x, points[0].y);
                for(var j = 1; j < points.length; j++){
                    context.lineTo(points[j].x, points[j].y);
                }
            }
        }
        context.stroke();
        
        context.beginPath();
        context.fillStyle = "rgba(150, 150, 255, 0.7)";
        for(var y = worldViewTop; y < worldViewBottom; y += gridSize){
            for(var x = worldViewLeft; x < worldViewRight; x += gridSize){
                context.moveTo(x, y);
                context.arc(x, y, 1 / zoomLevel, 0, 2 * Math.PI);
            }
        }
        context.fill();
}

function drawOrbits() {
    context.lineWidth = 1 / zoomLevel;
    for (var i = 0; i < particleList.length; i++) {
        var p = particleList[i];
        if (p.path.length > 1) {
            context.beginPath();
            context.strokeStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 0.5)`;
            context.moveTo(p.path[0].x, p.path[0].y);
            for (var j = 1; j < p.path.length; j++) {
                context.lineTo(p.path[j].x, p.path[j].y);
            }
            context.stroke();
        }
    }
}

function drawGravityWells() {
    for (var i = 0; i < particleList.length; i++) {
        var p = particleList[i];
        if (p.mass > 0) {
            var maxRadius = p.radius * 10 + Math.log(p.mass) * 5;
            var numCircles = 20;
            var colorBase = p.color;
            
            for (var j = 1; j <= numCircles; j++) {
                var currentRadius = maxRadius * (j / numCircles);
                var alpha = 0.3 * (1 - (j / numCircles));
                
                context.beginPath();
                context.arc(p.x, p.y, currentRadius, 0, 2 * Math.PI);
                context.strokeStyle = `rgba(${colorBase[0]}, ${colorBase[1]}, ${colorBase[2]}, ${alpha})`;
                context.lineWidth = 1 / zoomLevel;
                context.stroke();
            }
        }
    }
}

function drawGravitationalLensing() {
    // Create a temporary canvas for the lensing effect
    var lensingCanvas = document.createElement("canvas");
    lensingCanvas.width = width;
    lensingCanvas.height = height;
    var lensingContext = lensingCanvas.getContext("2d");
    
    // Draw the current state to the temp canvas
    lensingContext.save();
    lensingContext.translate(panX, panY);
    lensingContext.scale(zoomLevel, zoomLevel);
    
    // Draw all particles to the temp canvas
    for (var i = 0; i < particleList.length; i++) {
        var p = particleList[i];
        if (p.isBlackHole) {
            // Only black holes cause lensing in this simulation
            var distortionRadius = p.eventHorizonRadius * 10;
            
            // Create a radial gradient for the distortion
            var gradient = lensingContext.createRadialGradient(
                p.x, p.y, 0,
                p.x, p.y, distortionRadius
            );
            gradient.addColorStop(0, "rgba(0, 0, 0, 1)");
            gradient.addColorStop(0.7, "rgba(0, 0, 0, 0.8)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            
            lensingContext.beginPath();
            lensingContext.arc(p.x, p.y, distortionRadius, 0, 2 * Math.PI);
            lensingContext.fillStyle = gradient;
            lensingContext.fill();
        }
    }
    
    lensingContext.restore();
    
    // Apply the lensing effect as a displacement map
    context.globalCompositeOperation = "source-over";
    context.drawImage(lensingCanvas, 0, 0);
}



// New toggle function for gravitational lensing
function toggleGravitationalLensing() {
    showGravitationalLensing = !showGravitationalLensing;
    document.getElementById("toggleLensingBtn").innerHTML = 
        showGravitationalLensing ? "Hide Lensing" : "Show Lensing";
}
